---
phase: 02-authentication-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/requirements.txt
  - backend/app/core/security.py
  - backend/app/core/deps.py
  - backend/app/core/config.py
autonomous: true

must_haves:
  truths:
    - "Password hashing with Argon2 produces verifiable hashes"
    - "JWT access tokens can be created and decoded with user claims"
    - "JWT refresh tokens can be created and decoded with user claims"
    - "get_current_user dependency extracts user from valid JWT"
    - "require_role dependency blocks unauthorized roles with 403"
  artifacts:
    - path: "backend/app/core/security.py"
      provides: "JWT creation/verification and password hashing"
      exports: ["create_access_token", "create_refresh_token", "verify_password", "hash_password"]
    - path: "backend/app/core/deps.py"
      provides: "FastAPI auth dependencies for route protection"
      exports: ["get_current_user", "require_role", "oauth2_scheme"]
  key_links:
    - from: "backend/app/core/deps.py"
      to: "backend/app/core/security.py"
      via: "Import JWT constants and decode"
      pattern: "from app.core.security import"
    - from: "backend/app/core/security.py"
      to: "backend/app/core/config.py"
      via: "JWT secret key from settings"
      pattern: "settings.jwt_secret_key"
---

<objective>
Create the authentication security core: JWT token management with PyJWT, password hashing with pwdlib/Argon2, and FastAPI dependencies for route protection.

Purpose: Establish the security primitives that all auth endpoints and protected routes will use. This is the foundation for login, logout, and RBAC.
Output: security.py with JWT/password utilities, deps.py with auth dependencies.
</objective>

<execution_context>
@C:\Users\xande\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\xande\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-authentication-system/02-CONTEXT.md
@.planning/phases/02-authentication-system/02-RESEARCH.md

Existing codebase (from Phase 1):
- backend/app/core/config.py: Settings class with Pydantic BaseSettings
- backend/app/core/database.py: get_db dependency for async sessions
- backend/app/models/user.py: User model with email, password_hash, full_name, role, is_active

Research decisions:
- PyJWT (not python-jose - abandoned)
- pwdlib with Argon2 (not passlib - Python 3.13+ incompatible)
- 15-minute access tokens, 7-day refresh tokens
- Password hashing runs in threadpool (CPU-intensive, don't block event loop)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auth dependencies and update config</name>
  <files>
    backend/requirements.txt
    backend/app/core/config.py
  </files>
  <action>
    1. Update backend/requirements.txt to add:
       - PyJWT>=2.9.0
       - pwdlib[argon2]>=0.3.0
       - slowapi>=0.1.9

    2. Update backend/app/core/config.py to add JWT settings:
       - jwt_secret_key: str (required field, no default - MUST be set in env)
       - jwt_algorithm: str = "HS256"
       - access_token_expire_minutes: int = 15
       - refresh_token_expire_days: int = 7

    Note: jwt_secret_key should be a long random string (32+ chars). Generate with: python -c "import secrets; print(secrets.token_hex(32))"
  </action>
  <verify>
    cd backend && pip install -r requirements.txt
    python -c "import jwt; from pwdlib import PasswordHash; print('Auth deps OK')"
  </verify>
  <done>PyJWT and pwdlib installed, JWT config fields added to Settings</done>
</task>

<task type="auto">
  <name>Task 2: Create security utilities module</name>
  <files>
    backend/app/core/security.py
  </files>
  <action>
    Create backend/app/core/security.py with:

    1. Imports:
       - datetime, timedelta, timezone from datetime
       - jwt from PyJWT
       - PasswordHash from pwdlib
       - settings from app.core.config

    2. Password hasher instance:
       - password_hash = PasswordHash.recommended()
       - This uses Argon2 by default (secure, NIST recommended)

    3. Token creation functions:
       ```python
       def create_access_token(data: dict) -> str:
           """Create JWT access token with 15-minute expiry."""
           to_encode = data.copy()
           expire = datetime.now(timezone.utc) + timedelta(minutes=settings.access_token_expire_minutes)
           to_encode.update({"exp": expire, "type": "access"})
           return jwt.encode(to_encode, settings.jwt_secret_key, algorithm=settings.jwt_algorithm)

       def create_refresh_token(data: dict) -> str:
           """Create JWT refresh token with 7-day expiry."""
           to_encode = data.copy()
           expire = datetime.now(timezone.utc) + timedelta(days=settings.refresh_token_expire_days)
           to_encode.update({"exp": expire, "type": "refresh"})
           return jwt.encode(to_encode, settings.jwt_secret_key, algorithm=settings.jwt_algorithm)
       ```

    4. Password functions:
       ```python
       def verify_password(plain_password: str, hashed_password: str) -> bool:
           """Verify password against hash. Returns True if valid."""
           return password_hash.verify(plain_password, hashed_password)

       def hash_password(password: str) -> str:
           """Hash password using Argon2."""
           return password_hash.hash(password)
       ```

    5. Token decode function:
       ```python
       def decode_token(token: str) -> dict | None:
           """Decode and verify JWT token. Returns payload or None if invalid."""
           try:
               payload = jwt.decode(
                   token,
                   settings.jwt_secret_key,
                   algorithms=[settings.jwt_algorithm]
               )
               return payload
           except jwt.InvalidTokenError:
               return None
       ```
  </action>
  <verify>
    cd backend && python -c "
from app.core.security import hash_password, verify_password, create_access_token, decode_token
h = hash_password('Test123!')
assert verify_password('Test123!', h), 'Password verify failed'
token = create_access_token({'sub': 'test-user-id'})
payload = decode_token(token)
assert payload['sub'] == 'test-user-id', 'Token decode failed'
print('Security module OK')
"
  </verify>
  <done>security.py creates/verifies JWTs and hashes/verifies passwords</done>
</task>

<task type="auto">
  <name>Task 3: Create auth dependencies module</name>
  <files>
    backend/app/core/deps.py
  </files>
  <action>
    Create backend/app/core/deps.py with:

    1. Imports:
       - Annotated from typing
       - Depends, HTTPException, status from fastapi
       - OAuth2PasswordBearer from fastapi.security
       - AsyncSession from sqlalchemy.ext.asyncio
       - select from sqlalchemy
       - get_db from app.core.database
       - decode_token from app.core.security
       - User from app.models.user

    2. OAuth2 scheme:
       ```python
       oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")
       ```

    3. get_current_user dependency:
       ```python
       async def get_current_user(
           token: Annotated[str, Depends(oauth2_scheme)],
           db: AsyncSession = Depends(get_db)
       ) -> User:
           """Extract and validate current user from JWT token."""
           credentials_exception = HTTPException(
               status_code=status.HTTP_401_UNAUTHORIZED,
               detail="Token invalido ou expirado",
               headers={"WWW-Authenticate": "Bearer"},
           )

           payload = decode_token(token)
           if payload is None:
               raise credentials_exception

           if payload.get("type") != "access":
               raise credentials_exception

           user_id: str | None = payload.get("sub")
           if user_id is None:
               raise credentials_exception

           result = await db.execute(select(User).where(User.id == user_id))
           user = result.scalar_one_or_none()

           if user is None:
               raise credentials_exception

           if not user.is_active:
               raise HTTPException(
                   status_code=status.HTTP_401_UNAUTHORIZED,
                   detail="Usuario inativo"
               )

           return user
       ```

    4. require_role dependency factory:
       ```python
       def require_role(*allowed_roles: str):
           """Dependency factory for role-based access control.

           Usage:
               @router.get("/admin-only")
               async def admin_route(
                   user: Annotated[User, Depends(require_role("admin", "superadmin"))]
               ):
                   ...
           """
           async def role_checker(
               current_user: Annotated[User, Depends(get_current_user)]
           ) -> User:
               if current_user.role not in allowed_roles:
                   raise HTTPException(
                       status_code=status.HTTP_403_FORBIDDEN,
                       detail="Acesso negado - permissao insuficiente"
                   )
               return current_user
           return role_checker
       ```

    Note: Error messages are in Portuguese per CONTEXT.md decision (specific error messages).
  </action>
  <verify>
    cd backend && python -c "
from app.core.deps import oauth2_scheme, get_current_user, require_role
print('oauth2_scheme:', oauth2_scheme.scheme_name)
print('get_current_user:', get_current_user.__name__)
admin_checker = require_role('admin', 'superadmin')
print('require_role factory:', admin_checker.__name__)
print('Auth deps OK')
"
  </verify>
  <done>deps.py provides get_current_user and require_role dependencies for route protection</done>
</task>

</tasks>

<verification>
1. `pip install -r requirements.txt` installs PyJWT and pwdlib without errors
2. Password hash/verify round-trips correctly
3. JWT tokens encode/decode with correct claims and expiry
4. get_current_user is a valid FastAPI dependency
5. require_role factory creates dependency functions
6. Settings include jwt_secret_key, jwt_algorithm, token expiry settings
</verification>

<success_criteria>
- PyJWT>=2.9.0 and pwdlib[argon2]>=0.3.0 in requirements.txt
- security.py exports: create_access_token, create_refresh_token, verify_password, hash_password, decode_token
- deps.py exports: oauth2_scheme, get_current_user, require_role
- JWT tokens include "type" claim ("access" or "refresh")
- JWT tokens include "exp" claim with correct expiry
- Password hashing uses Argon2 (pwdlib.recommended())
- Error messages in Portuguese
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-system/02-01-SUMMARY.md`
</output>
