---
phase: 02-authentication-system
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - backend/app/api/v1/routes/users.py
  - backend/app/schemas/user.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/users creates new user when called by admin or superadmin"
    - "Admin can only create users in their own tenant"
    - "Superadmin can create users in any tenant"
    - "Admin cannot create superadmin users"
    - "GET /api/v1/users lists users filtered by tenant for admin, all for superadmin"
    - "DELETE /api/v1/users/{id} deletes user (checks for reports before delete)"
    - "User with role='user' or 'manager' cannot access user management endpoints"
  artifacts:
    - path: "backend/app/api/v1/routes/users.py"
      provides: "User CRUD endpoints (admin only)"
      exports: ["router"]
    - path: "backend/app/schemas/user.py"
      provides: "Extended user schemas with password validation"
      exports: ["UserCreate", "UserResponse", "UserUpdate"]
  key_links:
    - from: "backend/app/api/v1/routes/users.py"
      to: "backend/app/core/deps.py"
      via: "require_role dependency for admin access"
      pattern: "require_role.*admin.*superadmin"
    - from: "backend/app/api/v1/routes/users.py"
      to: "backend/app/core/security.py"
      via: "hash_password for new user creation"
      pattern: "hash_password"
---

<objective>
Create user management API endpoints: create, list, and delete users. Only admins can manage users in their tenant; superadmins have full access.

Purpose: Enable admins to create user accounts for technicians (AUTH-05). Per CONTEXT.md, there's no self-registration - admins create all accounts.
Output: Working /api/v1/users endpoints for user CRUD operations.
</objective>

<execution_context>
@C:\Users\xande\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\xande\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-authentication-system/02-CONTEXT.md
@.planning/phases/02-authentication-system/02-RESEARCH.md

From CONTEXT.md:
- Admin creates complete account with email + name + password
- Strong password: 8+ chars, uppercase, number, special character
- Hard delete only (no soft delete)
- Must handle FK constraints from reports

Role hierarchy:
- user: Create/edit/view only their own reports
- manager: Everything user can do + view all reports in tenant
- admin: Full tenant control (users, templates, branding)
- superadmin: God mode - full access to all tenants

From 02-01-PLAN: security.py with hash_password
From 02-02-PLAN: deps.py with require_role
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend user schemas with password validation</name>
  <files>
    backend/app/schemas/user.py
  </files>
  <action>
    Update backend/app/schemas/user.py to add:

    1. Strong password validator function:
       ```python
       import re
       from pydantic import field_validator

       def validate_strong_password(password: str) -> str:
           """Validate password meets strength requirements."""
           if len(password) < 8:
               raise ValueError("Senha deve ter no minimo 8 caracteres")
           if not re.search(r"[A-Z]", password):
               raise ValueError("Senha deve conter pelo menos uma letra maiuscula")
           if not re.search(r"[0-9]", password):
               raise ValueError("Senha deve conter pelo menos um numero")
           if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
               raise ValueError("Senha deve conter pelo menos um caractere especial")
           return password
       ```

    2. Update UserCreate class to use validator:
       ```python
       class UserCreate(UserBase):
           """Schema for creating a new user (admin only)."""
           password: str
           role: str = Field(default="user", pattern="^(user|manager|admin)$")
           tenant_id: UUID | None = None  # Only superadmin can specify

           @field_validator("password")
           @classmethod
           def password_strength(cls, v: str) -> str:
               return validate_strong_password(v)
       ```

    3. Add UserUpdate schema:
       ```python
       class UserUpdate(BaseModel):
           """Schema for updating user (admin only)."""
           full_name: str | None = None
           role: str | None = Field(default=None, pattern="^(user|manager|admin)$")
           is_active: bool | None = None
           password: str | None = None

           @field_validator("password")
           @classmethod
           def password_strength(cls, v: str | None) -> str | None:
               if v is not None:
                   return validate_strong_password(v)
               return v
       ```

    4. Add UserListResponse for paginated list:
       ```python
       class UserListResponse(BaseModel):
           """Paginated list of users."""
           users: list[UserResponse]
           total: int
       ```
  </action>
  <verify>
    cd backend && python -c "
from app.schemas.user import UserCreate, UserUpdate
from pydantic import ValidationError

# Test valid password
user = UserCreate(email='test@test.com', full_name='Test User', password='Test123!')
print('Valid password OK')

# Test weak password
try:
    UserCreate(email='test@test.com', full_name='Test', password='weak')
    assert False, 'Should have failed'
except ValidationError as e:
    print('Weak password rejected:', str(e.errors()[0]['msg']))

print('Password validation OK')
"
  </verify>
  <done>User schemas extended with strong password validation</done>
</task>

<task type="auto">
  <name>Task 2: Create user CRUD endpoints</name>
  <files>
    backend/app/api/v1/routes/users.py
    backend/app/main.py
  </files>
  <action>
    1. Create backend/app/api/v1/routes/users.py:
       ```python
       from typing import Annotated
       from uuid import UUID

       from fastapi import APIRouter, Depends, HTTPException, status, Query
       from sqlalchemy import select, func
       from sqlalchemy.ext.asyncio import AsyncSession

       from app.core.database import get_db
       from app.core.deps import require_role
       from app.core.security import hash_password
       from app.models.user import User
       from app.schemas.user import (
           UserCreate,
           UserResponse,
           UserUpdate,
           UserListResponse,
       )

       router = APIRouter(prefix="/users", tags=["users"])


       @router.post("/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
       async def create_user(
           user_data: UserCreate,
           current_user: Annotated[User, Depends(require_role("admin", "superadmin"))],
           db: AsyncSession = Depends(get_db),
       ):
           """
           Create a new user.

           - Admin: Can only create users in their own tenant
           - Superadmin: Can create users in any tenant
           - Admin cannot create superadmin users
           """
           # Determine tenant_id
           if current_user.role == "superadmin":
               # Superadmin can specify tenant, defaults to their own
               tenant_id = user_data.tenant_id or current_user.tenant_id
           else:
               # Admin can only create in their tenant
               tenant_id = current_user.tenant_id
               if user_data.tenant_id and user_data.tenant_id != tenant_id:
                   raise HTTPException(
                       status_code=status.HTTP_403_FORBIDDEN,
                       detail="Admin so pode criar usuarios no proprio tenant",
                   )

           # Admin cannot create superadmin
           if current_user.role == "admin" and user_data.role == "superadmin":
               raise HTTPException(
                   status_code=status.HTTP_403_FORBIDDEN,
                   detail="Admin nao pode criar usuarios superadmin",
               )

           # Check if email already exists
           result = await db.execute(
               select(User).where(User.email == user_data.email)
           )
           if result.scalar_one_or_none():
               raise HTTPException(
                   status_code=status.HTTP_400_BAD_REQUEST,
                   detail="Email ja cadastrado",
               )

           # Create user
           user = User(
               email=user_data.email,
               full_name=user_data.full_name,
               password_hash=hash_password(user_data.password),
               role=user_data.role,
               tenant_id=tenant_id,
           )

           db.add(user)
           await db.commit()
           await db.refresh(user)

           return UserResponse.model_validate(user)


       @router.get("/", response_model=UserListResponse)
       async def list_users(
           current_user: Annotated[User, Depends(require_role("admin", "superadmin"))],
           db: AsyncSession = Depends(get_db),
           skip: int = Query(0, ge=0),
           limit: int = Query(50, ge=1, le=100),
       ):
           """
           List users.

           - Admin: Sees only users in their tenant
           - Superadmin: Sees all users
           """
           # Build query
           query = select(User)

           if current_user.role != "superadmin":
               # Admin sees only their tenant
               query = query.where(User.tenant_id == current_user.tenant_id)

           # Get total count
           count_query = select(func.count()).select_from(query.subquery())
           total = await db.scalar(count_query)

           # Get paginated results
           query = query.offset(skip).limit(limit).order_by(User.created_at.desc())
           result = await db.execute(query)
           users = result.scalars().all()

           return UserListResponse(
               users=[UserResponse.model_validate(u) for u in users],
               total=total or 0,
           )


       @router.get("/{user_id}", response_model=UserResponse)
       async def get_user(
           user_id: UUID,
           current_user: Annotated[User, Depends(require_role("admin", "superadmin"))],
           db: AsyncSession = Depends(get_db),
       ):
           """Get a specific user by ID."""
           result = await db.execute(select(User).where(User.id == user_id))
           user = result.scalar_one_or_none()

           if not user:
               raise HTTPException(
                   status_code=status.HTTP_404_NOT_FOUND,
                   detail="Usuario nao encontrado",
               )

           # Admin can only see users in their tenant
           if current_user.role != "superadmin" and user.tenant_id != current_user.tenant_id:
               raise HTTPException(
                   status_code=status.HTTP_403_FORBIDDEN,
                   detail="Acesso negado",
               )

           return UserResponse.model_validate(user)


       @router.patch("/{user_id}", response_model=UserResponse)
       async def update_user(
           user_id: UUID,
           user_data: UserUpdate,
           current_user: Annotated[User, Depends(require_role("admin", "superadmin"))],
           db: AsyncSession = Depends(get_db),
       ):
           """Update a user."""
           result = await db.execute(select(User).where(User.id == user_id))
           user = result.scalar_one_or_none()

           if not user:
               raise HTTPException(
                   status_code=status.HTTP_404_NOT_FOUND,
                   detail="Usuario nao encontrado",
               )

           # Admin can only update users in their tenant
           if current_user.role != "superadmin" and user.tenant_id != current_user.tenant_id:
               raise HTTPException(
                   status_code=status.HTTP_403_FORBIDDEN,
                   detail="Acesso negado",
               )

           # Admin cannot promote to superadmin
           if current_user.role == "admin" and user_data.role == "superadmin":
               raise HTTPException(
                   status_code=status.HTTP_403_FORBIDDEN,
                   detail="Admin nao pode promover usuarios a superadmin",
               )

           # Update fields
           if user_data.full_name is not None:
               user.full_name = user_data.full_name
           if user_data.role is not None:
               user.role = user_data.role
           if user_data.is_active is not None:
               user.is_active = user_data.is_active
           if user_data.password is not None:
               user.password_hash = hash_password(user_data.password)

           await db.commit()
           await db.refresh(user)

           return UserResponse.model_validate(user)


       @router.delete("/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
       async def delete_user(
           user_id: UUID,
           current_user: Annotated[User, Depends(require_role("admin", "superadmin"))],
           db: AsyncSession = Depends(get_db),
       ):
           """
           Delete a user.

           Per CONTEXT.md: hard delete only (no soft delete).
           Note: Check for dependent reports before deleting.
           """
           result = await db.execute(select(User).where(User.id == user_id))
           user = result.scalar_one_or_none()

           if not user:
               raise HTTPException(
                   status_code=status.HTTP_404_NOT_FOUND,
                   detail="Usuario nao encontrado",
               )

           # Admin can only delete users in their tenant
           if current_user.role != "superadmin" and user.tenant_id != current_user.tenant_id:
               raise HTTPException(
                   status_code=status.HTTP_403_FORBIDDEN,
                   detail="Acesso negado",
               )

           # Cannot delete yourself
           if user.id == current_user.id:
               raise HTTPException(
                   status_code=status.HTTP_400_BAD_REQUEST,
                   detail="Nao e possivel excluir o proprio usuario",
               )

           # TODO: In Phase 6, check for reports and reassign or block
           # For now, just delete (no reports exist yet)

           await db.delete(user)
           await db.commit()

           return None
       ```

    2. Update backend/app/main.py to include users router:
       ```python
       from app.api.v1.routes.users import router as users_router
       app.include_router(users_router, prefix="/api/v1")
       ```
  </action>
  <verify>
    cd backend && python -c "
from fastapi.testclient import TestClient
from app.main import app

# Check users routes are registered
routes = [r.path for r in app.routes]
print('Routes:', [r for r in routes if 'users' in r])
assert '/api/v1/users' in routes or '/api/v1/users/' in routes, 'Users routes missing'
print('Users routes OK')
"
  </verify>
  <done>User CRUD endpoints created with proper RBAC and tenant isolation</done>
</task>

</tasks>

<verification>
1. POST /api/v1/users with admin token creates user in admin's tenant
2. POST /api/v1/users with superadmin can specify any tenant_id
3. POST /api/v1/users with user/manager token returns 403
4. POST /api/v1/users with admin trying to create superadmin returns 403
5. POST /api/v1/users with weak password returns 422 with validation error
6. GET /api/v1/users with admin returns only their tenant's users
7. GET /api/v1/users with superadmin returns all users
8. DELETE /api/v1/users/{id} deletes user (returns 204)
9. DELETE own user returns 400 error
</verification>

<success_criteria>
- POST /api/v1/users creates users (admin/superadmin only)
- Strong password validation: 8+ chars, uppercase, number, special char
- Admin restricted to own tenant, superadmin has full access
- Admin cannot create superadmin role
- GET /api/v1/users returns paginated list with tenant filtering
- PATCH /api/v1/users/{id} updates user fields including password
- DELETE /api/v1/users/{id} hard deletes user
- All error messages in Portuguese
- RBAC enforced via require_role dependency
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-system/02-03-SUMMARY.md`
</output>
