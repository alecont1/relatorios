---
phase: 02-authentication-system
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/package.json
  - frontend/src/lib/axios.ts
  - frontend/src/features/auth/store.ts
  - frontend/src/features/auth/types.ts
  - frontend/src/features/auth/api.ts
  - frontend/src/features/auth/components/ProtectedRoute.tsx
autonomous: true

must_haves:
  truths:
    - "Axios instance sends access token in Authorization header"
    - "Axios interceptor automatically refreshes token on 401 response"
    - "Auth store persists user info across page refreshes"
    - "ProtectedRoute redirects unauthenticated users to /login"
    - "ProtectedRoute blocks access based on allowed roles"
  artifacts:
    - path: "frontend/src/lib/axios.ts"
      provides: "Configured Axios instance with auth interceptors"
      exports: ["api"]
    - path: "frontend/src/features/auth/store.ts"
      provides: "Zustand auth store with persist middleware"
      exports: ["useAuthStore"]
    - path: "frontend/src/features/auth/components/ProtectedRoute.tsx"
      provides: "Route guard component for protected pages"
      exports: ["ProtectedRoute"]
  key_links:
    - from: "frontend/src/lib/axios.ts"
      to: "frontend/src/features/auth/store.ts"
      via: "Get token from store for requests"
      pattern: "useAuthStore.getState"
    - from: "frontend/src/features/auth/components/ProtectedRoute.tsx"
      to: "frontend/src/features/auth/store.ts"
      via: "Check authentication state"
      pattern: "useAuthStore"
---

<objective>
Create frontend authentication infrastructure: Axios instance with token interceptors, Zustand auth store with persistence, and ProtectedRoute component.

Purpose: Establish the client-side auth foundation that login UI and protected pages will use. Access token stored in memory, refresh via httpOnly cookie.
Output: Working axios.ts, auth store, and ProtectedRoute component.
</objective>

<execution_context>
@C:\Users\xande\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\xande\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-authentication-system/02-CONTEXT.md
@.planning/phases/02-authentication-system/02-RESEARCH.md

From RESEARCH.md:
- Access token in memory (React state/Zustand)
- Refresh token in httpOnly cookie (sent automatically with withCredentials)
- On 401, attempt token refresh before failing
- Zustand persist middleware for user info (NOT access token)
- React Router Navigate for redirects

Existing frontend (from Phase 1):
- React 18, React Router 6.28, Zustand 4.5.5, React Query 5.x
- frontend/src/lib/queryClient.ts already exists
- frontend/src/stores/ directory for Zustand stores
- @/* path alias configured

No external packages needed - all deps already in package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Axios and Lucide icons, create types</name>
  <files>
    frontend/package.json
    frontend/src/features/auth/types.ts
  </files>
  <action>
    1. Update frontend/package.json to add:
       - "axios": "^1.7.0"
       - "lucide-react": "^0.469.0"

       Run: cd frontend && npm install axios lucide-react

    2. Create frontend/src/features/auth/types.ts:
       ```typescript
       export type UserRole = 'user' | 'manager' | 'admin' | 'superadmin';

       export interface User {
         id: string;
         email: string;
         full_name: string;
         role: UserRole;
         tenant_id: string;
         is_active: boolean;
         created_at: string;
       }

       export interface AuthState {
         user: User | null;
         accessToken: string | null;
         isAuthenticated: boolean;
         isLoading: boolean;
         setAuth: (user: User, accessToken: string) => void;
         clearAuth: () => void;
         setLoading: (loading: boolean) => void;
         setAccessToken: (token: string) => void;
       }

       export interface LoginRequest {
         email: string;
         password: string;
       }

       export interface LoginResponse {
         user: User;
         access_token: string;
         token_type: string;
       }
       ```

    3. Create directory structure:
       - frontend/src/features/auth/
       - frontend/src/features/auth/components/
       - frontend/src/features/auth/hooks/
  </action>
  <verify>
    cd frontend && npm ls axios lucide-react
    ls -la src/features/auth/
  </verify>
  <done>Axios and Lucide icons installed, auth types defined</done>
</task>

<task type="auto">
  <name>Task 2: Create Axios instance with interceptors</name>
  <files>
    frontend/src/lib/axios.ts
  </files>
  <action>
    Create frontend/src/lib/axios.ts:
    ```typescript
    import axios, { AxiosError, InternalAxiosRequestConfig } from 'axios';

    const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000';

    /**
     * Configured Axios instance for API requests.
     *
     * Features:
     * - Sends access token in Authorization header
     * - Sends cookies with requests (for refresh token)
     * - Auto-refreshes token on 401 response
     * - Redirects to login on refresh failure
     */
    export const api = axios.create({
      baseURL: API_URL,
      withCredentials: true, // Send cookies (refresh token)
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // Track if we're currently refreshing to prevent infinite loops
    let isRefreshing = false;
    let failedQueue: Array<{
      resolve: (token: string) => void;
      reject: (error: Error) => void;
    }> = [];

    const processQueue = (error: Error | null, token: string | null = null) => {
      failedQueue.forEach((promise) => {
        if (error) {
          promise.reject(error);
        } else if (token) {
          promise.resolve(token);
        }
      });
      failedQueue = [];
    };

    // Request interceptor - add access token
    api.interceptors.request.use(
      (config: InternalAxiosRequestConfig) => {
        // Import here to avoid circular dependency
        const { useAuthStore } = require('@/features/auth/store');
        const accessToken = useAuthStore.getState().accessToken;

        if (accessToken && config.headers) {
          config.headers.Authorization = `Bearer ${accessToken}`;
        }

        return config;
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor - handle token refresh
    api.interceptors.response.use(
      (response) => response,
      async (error: AxiosError) => {
        const originalRequest = error.config as InternalAxiosRequestConfig & {
          _retry?: boolean;
        };

        // Only retry on 401 and if we haven't already retried
        if (error.response?.status !== 401 || originalRequest._retry) {
          return Promise.reject(error);
        }

        // Don't retry refresh endpoint itself
        if (originalRequest.url?.includes('/auth/refresh')) {
          return Promise.reject(error);
        }

        if (isRefreshing) {
          // If refresh is in progress, queue this request
          return new Promise((resolve, reject) => {
            failedQueue.push({
              resolve: (token: string) => {
                if (originalRequest.headers) {
                  originalRequest.headers.Authorization = `Bearer ${token}`;
                }
                resolve(api(originalRequest));
              },
              reject: (err: Error) => {
                reject(err);
              },
            });
          });
        }

        originalRequest._retry = true;
        isRefreshing = true;

        try {
          // Attempt to refresh token
          const { data } = await axios.post<{
            user: unknown;
            access_token: string;
          }>(
            `${API_URL}/api/v1/auth/refresh`,
            {},
            { withCredentials: true }
          );

          // Update auth store with new token
          const { useAuthStore } = require('@/features/auth/store');
          useAuthStore.getState().setAccessToken(data.access_token);

          // Process queued requests with new token
          processQueue(null, data.access_token);

          // Retry original request with new token
          if (originalRequest.headers) {
            originalRequest.headers.Authorization = `Bearer ${data.access_token}`;
          }
          return api(originalRequest);
        } catch (refreshError) {
          // Refresh failed - clear auth and redirect to login
          processQueue(refreshError as Error);

          const { useAuthStore } = require('@/features/auth/store');
          useAuthStore.getState().clearAuth();

          // Redirect to login (preserve current path for redirect after login)
          const currentPath = window.location.pathname;
          if (currentPath !== '/login') {
            window.location.href = `/login?redirect=${encodeURIComponent(currentPath)}`;
          }

          return Promise.reject(refreshError);
        } finally {
          isRefreshing = false;
        }
      }
    );

    export default api;
    ```
  </action>
  <verify>
    cd frontend && npx tsc --noEmit src/lib/axios.ts 2>&1 | head -20
    # Should compile without errors (may show warning about store import)
  </verify>
  <done>Axios instance created with auth interceptors and automatic token refresh</done>
</task>

<task type="auto">
  <name>Task 3: Create Zustand auth store and ProtectedRoute</name>
  <files>
    frontend/src/features/auth/store.ts
    frontend/src/features/auth/components/ProtectedRoute.tsx
    frontend/src/features/auth/api.ts
    frontend/src/features/auth/index.ts
  </files>
  <action>
    1. Create frontend/src/features/auth/store.ts:
       ```typescript
       import { create } from 'zustand';
       import { persist, createJSONStorage } from 'zustand/middleware';
       import type { AuthState, User } from './types';

       /**
        * Zustand auth store with persistence.
        *
        * - User info persisted to localStorage (survives refresh)
        * - Access token stored in memory only (security)
        * - On refresh, token is recovered via /auth/refresh endpoint
        */
       export const useAuthStore = create<AuthState>()(
         persist(
           (set) => ({
             user: null,
             accessToken: null,
             isAuthenticated: false,
             isLoading: true,

             setAuth: (user: User, accessToken: string) =>
               set({
                 user,
                 accessToken,
                 isAuthenticated: true,
                 isLoading: false,
               }),

             clearAuth: () =>
               set({
                 user: null,
                 accessToken: null,
                 isAuthenticated: false,
                 isLoading: false,
               }),

             setLoading: (loading: boolean) =>
               set({ isLoading: loading }),

             setAccessToken: (token: string) =>
               set({ accessToken: token }),
           }),
           {
             name: 'smarthand-auth',
             storage: createJSONStorage(() => localStorage),
             // Only persist user info, NOT access token (security)
             partialize: (state) => ({
               user: state.user,
               isAuthenticated: state.isAuthenticated,
             }),
             // On rehydration, set loading to trigger token refresh
             onRehydrateStorage: () => (state) => {
               if (state) {
                 // If we have persisted user but no token, we need to refresh
                 if (state.isAuthenticated && !state.accessToken) {
                   state.isLoading = true;
                 } else {
                   state.isLoading = false;
                 }
               }
             },
           }
         )
       );
       ```

    2. Create frontend/src/features/auth/api.ts:
       ```typescript
       import { useMutation, useQueryClient } from '@tanstack/react-query';
       import { api } from '@/lib/axios';
       import { useAuthStore } from './store';
       import type { LoginRequest, LoginResponse } from './types';

       /**
        * Login mutation hook.
        * Authenticates user and stores auth state.
        */
       export function useLogin() {
         const queryClient = useQueryClient();
         const setAuth = useAuthStore((state) => state.setAuth);

         return useMutation({
           mutationFn: async (credentials: LoginRequest): Promise<LoginResponse> => {
             // Use form data format for OAuth2PasswordRequestForm
             const formData = new URLSearchParams();
             formData.append('username', credentials.email);
             formData.append('password', credentials.password);

             const { data } = await api.post<LoginResponse>(
               '/api/v1/auth/login',
               formData,
               {
                 headers: {
                   'Content-Type': 'application/x-www-form-urlencoded',
                 },
               }
             );

             return data;
           },
           onSuccess: (data) => {
             setAuth(data.user, data.access_token);
             queryClient.clear(); // Clear any stale queries
           },
         });
       }

       /**
        * Logout mutation hook.
        * Clears auth state and server-side refresh token.
        */
       export function useLogout() {
         const queryClient = useQueryClient();
         const clearAuth = useAuthStore((state) => state.clearAuth);

         return useMutation({
           mutationFn: async (): Promise<void> => {
             await api.post('/api/v1/auth/logout');
           },
           onSuccess: () => {
             clearAuth();
             queryClient.clear();
           },
           onError: () => {
             // Clear auth even if server call fails
             clearAuth();
             queryClient.clear();
           },
         });
       }

       /**
        * Refresh token hook.
        * Used on app startup to recover session.
        */
       export function useRefreshToken() {
         const setAuth = useAuthStore((state) => state.setAuth);
         const clearAuth = useAuthStore((state) => state.clearAuth);
         const setLoading = useAuthStore((state) => state.setLoading);

         return useMutation({
           mutationFn: async (): Promise<LoginResponse> => {
             const { data } = await api.post<LoginResponse>('/api/v1/auth/refresh');
             return data;
           },
           onSuccess: (data) => {
             setAuth(data.user, data.access_token);
           },
           onError: () => {
             clearAuth();
           },
           onSettled: () => {
             setLoading(false);
           },
         });
       }
       ```

    3. Create frontend/src/features/auth/components/ProtectedRoute.tsx:
       ```typescript
       import { Navigate, useLocation } from 'react-router-dom';
       import { useAuthStore } from '../store';
       import type { UserRole } from '../types';

       interface ProtectedRouteProps {
         children: React.ReactNode;
         allowedRoles?: UserRole[];
       }

       /**
        * Route guard component.
        *
        * - Redirects unauthenticated users to /login
        * - Blocks access if user role not in allowedRoles
        * - Shows loading state while auth is initializing
        */
       export function ProtectedRoute({
         children,
         allowedRoles,
       }: ProtectedRouteProps) {
         const { isAuthenticated, isLoading, user } = useAuthStore();
         const location = useLocation();

         // Show loading while auth state is initializing
         if (isLoading) {
           return (
             <div className="flex min-h-screen items-center justify-center">
               <div className="text-lg">Carregando...</div>
             </div>
           );
         }

         // Redirect to login if not authenticated
         if (!isAuthenticated) {
           // Preserve the attempted URL for redirect after login
           return (
             <Navigate
               to="/login"
               state={{ from: location }}
               replace
             />
           );
         }

         // Check role-based access
         if (allowedRoles && user && !allowedRoles.includes(user.role)) {
           return (
             <Navigate
               to="/unauthorized"
               replace
             />
           );
         }

         return <>{children}</>;
       }
       ```

    4. Create frontend/src/features/auth/index.ts (barrel export):
       ```typescript
       export { useAuthStore } from './store';
       export { useLogin, useLogout, useRefreshToken } from './api';
       export { ProtectedRoute } from './components/ProtectedRoute';
       export type { User, UserRole, AuthState, LoginRequest, LoginResponse } from './types';
       ```
  </action>
  <verify>
    cd frontend && npx tsc --noEmit
    # Should compile without errors
  </verify>
  <done>Auth store with persistence and ProtectedRoute component created</done>
</task>

</tasks>

<verification>
1. npm install completes without errors
2. TypeScript compiles without errors
3. useAuthStore can be imported and used
4. api instance has request and response interceptors configured
5. ProtectedRoute component renders children when authenticated
6. ProtectedRoute redirects to /login when not authenticated
7. Login mutation uses form data format for OAuth2
</verification>

<success_criteria>
- axios and lucide-react in package.json
- api.ts Axios instance with withCredentials=true
- Request interceptor adds Bearer token from store
- Response interceptor handles 401 with token refresh
- Auth store persists user but not accessToken
- ProtectedRoute handles loading, auth, and role checks
- Barrel export from features/auth/index.ts
- All TypeScript types defined in types.ts
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-system/02-04-SUMMARY.md`
</output>
