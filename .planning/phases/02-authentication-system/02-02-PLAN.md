---
phase: 02-authentication-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/schemas/auth.py
  - backend/app/schemas/user.py
  - backend/app/api/v1/routes/auth.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/auth/login returns access token and user data on valid credentials"
    - "POST /api/v1/auth/login returns 401 with 'Email nao encontrado' for unknown email"
    - "POST /api/v1/auth/login returns 401 with 'Senha incorreta' for wrong password"
    - "POST /api/v1/auth/login sets httpOnly refresh token cookie"
    - "POST /api/v1/auth/refresh returns new access token using refresh cookie"
    - "POST /api/v1/auth/logout clears the refresh token cookie"
    - "Login endpoint is rate limited to 5 requests per minute per IP"
  artifacts:
    - path: "backend/app/schemas/auth.py"
      provides: "Pydantic schemas for auth request/response"
      exports: ["Token", "TokenData", "LoginRequest"]
    - path: "backend/app/schemas/user.py"
      provides: "Pydantic schemas for user data"
      exports: ["UserResponse", "UserCreate"]
    - path: "backend/app/api/v1/routes/auth.py"
      provides: "Auth endpoints (login, logout, refresh)"
      exports: ["router"]
  key_links:
    - from: "backend/app/api/v1/routes/auth.py"
      to: "backend/app/core/security.py"
      via: "Token creation and password verification"
      pattern: "from app.core.security import"
    - from: "backend/app/main.py"
      to: "backend/app/api/v1/routes/auth.py"
      via: "Router registration"
      pattern: "include_router.*auth"
---

<objective>
Create auth schemas and backend authentication endpoints: login with email/password, token refresh via httpOnly cookie, and logout.

Purpose: Enable users to authenticate and maintain sessions. Login returns access token in response body and sets refresh token in secure cookie.
Output: Working /api/v1/auth/login, /refresh, and /logout endpoints.
</objective>

<execution_context>
@C:\Users\xande\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\xande\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-authentication-system/02-CONTEXT.md
@.planning/phases/02-authentication-system/02-RESEARCH.md

From CONTEXT.md:
- Login identifier: email (not username)
- Error messages: specific ("Email nao encontrado" or "Senha incorreta")
- No "forgot password" flow in v1 - admin resets manually

From RESEARCH.md:
- Use OAuth2PasswordRequestForm for login (FastAPI standard)
- Store refresh token in httpOnly cookie with Secure and SameSite=strict
- Access token returned in response body (stored in memory on frontend)
- Rate limit login: 5/minute per IP using SlowAPI
- Run password verification in threadpool (CPU-intensive)

Existing:
- backend/app/models/user.py: User model with email, password_hash, full_name, role
- Will use security.py and deps.py from 02-01-PLAN (parallel execution)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth and user schemas</name>
  <files>
    backend/app/schemas/auth.py
    backend/app/schemas/user.py
  </files>
  <action>
    1. Create backend/app/schemas/auth.py:
       ```python
       from pydantic import BaseModel, EmailStr

       class LoginRequest(BaseModel):
           """Login request with email and password."""
           email: EmailStr
           password: str

       class Token(BaseModel):
           """Token response returned on successful login."""
           access_token: str
           token_type: str = "bearer"

       class TokenData(BaseModel):
           """Decoded token payload data."""
           sub: str | None = None
           tenant_id: str | None = None
           role: str | None = None
           type: str | None = None
       ```

    2. Create backend/app/schemas/user.py:
       ```python
       from uuid import UUID
       from datetime import datetime
       from pydantic import BaseModel, EmailStr, Field

       class UserBase(BaseModel):
           """Base user fields."""
           email: EmailStr
           full_name: str = Field(min_length=2, max_length=255)

       class UserCreate(UserBase):
           """Schema for creating a new user (admin only)."""
           password: str = Field(
               min_length=8,
               description="Minimum 8 characters, must include uppercase, number, and special character"
           )
           role: str = Field(default="user", pattern="^(user|manager|admin)$")
           # tenant_id is set from current_user for admin, or specified by superadmin

       class UserResponse(UserBase):
           """User data returned in API responses."""
           id: UUID
           role: str
           tenant_id: UUID
           is_active: bool
           created_at: datetime

           model_config = {"from_attributes": True}

       class UserWithToken(BaseModel):
           """Login response with user data and access token."""
           user: UserResponse
           access_token: str
           token_type: str = "bearer"
       ```

    Note: UserCreate has password validation (8+ chars). The regex validation for uppercase/number/special is done in the endpoint for clearer error messages.
  </action>
  <verify>
    cd backend && python -c "
from app.schemas.auth import LoginRequest, Token, TokenData
from app.schemas.user import UserCreate, UserResponse, UserWithToken
print('LoginRequest fields:', LoginRequest.model_fields.keys())
print('UserResponse fields:', UserResponse.model_fields.keys())
print('Schemas OK')
"
  </verify>
  <done>Auth and user Pydantic schemas created with proper validation</done>
</task>

<task type="auto">
  <name>Task 2: Create auth routes with rate limiting</name>
  <files>
    backend/app/api/v1/routes/auth.py
    backend/app/main.py
  </files>
  <action>
    1. Create backend/app/api/v1/routes/auth.py:
       ```python
       from typing import Annotated

       from fastapi import APIRouter, Depends, HTTPException, status, Response, Request, Cookie
       from fastapi.security import OAuth2PasswordRequestForm
       from slowapi import Limiter
       from slowapi.util import get_remote_address
       from sqlalchemy import select
       from sqlalchemy.ext.asyncio import AsyncSession
       from starlette.concurrency import run_in_threadpool

       from app.core.database import get_db
       from app.core.security import (
           create_access_token,
           create_refresh_token,
           verify_password,
           decode_token,
       )
       from app.core.deps import get_current_user
       from app.models.user import User
       from app.schemas.user import UserResponse, UserWithToken

       router = APIRouter(prefix="/auth", tags=["auth"])
       limiter = Limiter(key_func=get_remote_address)


       @router.post("/login", response_model=UserWithToken)
       @limiter.limit("5/minute")
       async def login(
           request: Request,
           response: Response,
           form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
           db: AsyncSession = Depends(get_db),
       ):
           """
           Authenticate user with email and password.

           Returns access token in response body.
           Sets refresh token in httpOnly cookie.
           """
           # Find user by email (form_data.username is the email)
           result = await db.execute(
               select(User).where(User.email == form_data.username)
           )
           user = result.scalar_one_or_none()

           if not user:
               raise HTTPException(
                   status_code=status.HTTP_401_UNAUTHORIZED,
                   detail="Email nao encontrado",
               )

           if not user.is_active:
               raise HTTPException(
                   status_code=status.HTTP_401_UNAUTHORIZED,
                   detail="Usuario inativo",
               )

           # Verify password in thread pool (CPU-intensive Argon2)
           is_valid = await run_in_threadpool(
               verify_password, form_data.password, user.password_hash
           )

           if not is_valid:
               raise HTTPException(
                   status_code=status.HTTP_401_UNAUTHORIZED,
                   detail="Senha incorreta",
               )

           # Create tokens with user claims
           token_data = {
               "sub": str(user.id),
               "tenant_id": str(user.tenant_id),
               "role": user.role,
           }
           access_token = create_access_token(token_data)
           refresh_token = create_refresh_token(token_data)

           # Set refresh token in httpOnly cookie
           response.set_cookie(
               key="refresh_token",
               value=refresh_token,
               httponly=True,
               secure=True,  # HTTPS only in production
               samesite="strict",
               max_age=7 * 24 * 60 * 60,  # 7 days in seconds
               path="/api/v1/auth",  # Only sent to auth endpoints
           )

           return UserWithToken(
               user=UserResponse.model_validate(user),
               access_token=access_token,
           )


       @router.post("/refresh", response_model=UserWithToken)
       async def refresh_token(
           request: Request,
           response: Response,
           refresh_token: Annotated[str | None, Cookie()] = None,
           db: AsyncSession = Depends(get_db),
       ):
           """
           Get new access token using refresh token from cookie.

           Also rotates the refresh token (issues new one, old becomes invalid).
           """
           if not refresh_token:
               raise HTTPException(
                   status_code=status.HTTP_401_UNAUTHORIZED,
                   detail="Refresh token ausente",
               )

           payload = decode_token(refresh_token)
           if payload is None:
               raise HTTPException(
                   status_code=status.HTTP_401_UNAUTHORIZED,
                   detail="Refresh token invalido ou expirado",
               )

           if payload.get("type") != "refresh":
               raise HTTPException(
                   status_code=status.HTTP_401_UNAUTHORIZED,
                   detail="Token invalido",
               )

           user_id = payload.get("sub")
           if not user_id:
               raise HTTPException(
                   status_code=status.HTTP_401_UNAUTHORIZED,
                   detail="Token invalido",
               )

           # Get user from database
           result = await db.execute(select(User).where(User.id == user_id))
           user = result.scalar_one_or_none()

           if not user or not user.is_active:
               raise HTTPException(
                   status_code=status.HTTP_401_UNAUTHORIZED,
                   detail="Usuario nao encontrado ou inativo",
               )

           # Create new tokens (rotation)
           token_data = {
               "sub": str(user.id),
               "tenant_id": str(user.tenant_id),
               "role": user.role,
           }
           new_access_token = create_access_token(token_data)
           new_refresh_token = create_refresh_token(token_data)

           # Set new refresh token cookie
           response.set_cookie(
               key="refresh_token",
               value=new_refresh_token,
               httponly=True,
               secure=True,
               samesite="strict",
               max_age=7 * 24 * 60 * 60,
               path="/api/v1/auth",
           )

           return UserWithToken(
               user=UserResponse.model_validate(user),
               access_token=new_access_token,
           )


       @router.post("/logout")
       async def logout(
           response: Response,
           current_user: Annotated[User, Depends(get_current_user)],
       ):
           """
           Logout current user by clearing refresh token cookie.

           Note: Access token remains valid until expiry (15 min).
           For immediate invalidation, implement token blacklist (future).
           """
           response.delete_cookie(
               key="refresh_token",
               path="/api/v1/auth",
               httponly=True,
               secure=True,
               samesite="strict",
           )

           return {"message": "Logout realizado com sucesso"}


       @router.get("/me", response_model=UserResponse)
       async def get_current_user_info(
           current_user: Annotated[User, Depends(get_current_user)],
       ):
           """Get current authenticated user's information."""
           return UserResponse.model_validate(current_user)
       ```

    2. Update backend/app/main.py to:
       - Add SlowAPI exception handler
       - Import and include auth router

       Add after existing imports:
       ```python
       from slowapi import _rate_limit_exceeded_handler
       from slowapi.errors import RateLimitExceeded
       from slowapi.middleware import SlowAPIMiddleware
       ```

       Add after app creation:
       ```python
       # Rate limiting
       from slowapi import Limiter
       from slowapi.util import get_remote_address
       limiter = Limiter(key_func=get_remote_address)
       app.state.limiter = limiter
       app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)
       ```

       Add router import and include:
       ```python
       from app.api.v1.routes.auth import router as auth_router
       app.include_router(auth_router, prefix="/api/v1")
       ```
  </action>
  <verify>
    cd backend && python -c "
from fastapi.testclient import TestClient
from app.main import app
client = TestClient(app)

# Check auth routes are registered
routes = [r.path for r in app.routes]
print('Routes:', [r for r in routes if 'auth' in r])
assert '/api/v1/auth/login' in routes, 'Login route missing'
assert '/api/v1/auth/refresh' in routes, 'Refresh route missing'
assert '/api/v1/auth/logout' in routes, 'Logout route missing'
print('Auth routes OK')
"
  </verify>
  <done>Auth endpoints created: login with rate limiting, refresh with rotation, logout with cookie clear</done>
</task>

</tasks>

<verification>
1. POST /api/v1/auth/login with valid credentials returns UserWithToken
2. POST /api/v1/auth/login with unknown email returns 401 "Email nao encontrado"
3. POST /api/v1/auth/login with wrong password returns 401 "Senha incorreta"
4. Login response sets httpOnly refresh_token cookie
5. POST /api/v1/auth/refresh with valid cookie returns new tokens
6. POST /api/v1/auth/logout clears refresh_token cookie
7. GET /api/v1/auth/me returns current user info
8. 6th login attempt within 1 minute returns 429 rate limit error
</verification>

<success_criteria>
- /api/v1/auth/login endpoint accepts OAuth2PasswordRequestForm
- Login returns UserWithToken with access_token and user data
- Refresh token stored in httpOnly, Secure, SameSite=strict cookie
- Token refresh rotates the refresh token
- Error messages in Portuguese: "Email nao encontrado", "Senha incorreta"
- Rate limiting active: 5/minute on login
- SlowAPI configured in main.py
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-system/02-02-SUMMARY.md`
</output>
