---
phase: 01-setup-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - backend/alembic.ini
  - backend/alembic/env.py
  - backend/alembic/script.py.mako
  - backend/alembic/versions/001_initial_schema.py
  - backend/app/models/tenant.py
  - backend/app/models/user.py
  - backend/app/models/template.py
  - backend/app/models/project.py
  - backend/app/models/report.py
  - backend/app/models/report_photo.py
  - backend/app/models/__init__.py
autonomous: true

must_haves:
  truths:
    - "alembic upgrade head runs without errors against a PostgreSQL database"
    - "All 6 tables are created with correct names: tenants, users, templates, projects, reports, report_photos"
    - "PostGIS extension is enabled before geometry columns are used"
    - "All tables have UUID primary keys, tenant_id foreign keys, and timestamp columns"
    - "alembic revision --autogenerate detects model changes"
    - "SQLAlchemy model schemas match Alembic migration table definitions"
  artifacts:
    - path: "backend/alembic.ini"
      provides: "Alembic configuration"
      contains: "sqlalchemy.url"
    - path: "backend/alembic/env.py"
      provides: "Async Alembic environment"
      contains: "run_async_migrations"
    - path: "backend/alembic/versions/001_initial_schema.py"
      provides: "Initial migration with PostGIS + all tables"
      contains: "CREATE EXTENSION"
    - path: "backend/app/models/tenant.py"
      provides: "Tenant SQLAlchemy model"
      contains: "class Tenant"
    - path: "backend/app/models/report.py"
      provides: "Report SQLAlchemy model with location column"
      contains: "class Report"
  key_links:
    - from: "backend/alembic/env.py"
      to: "backend/app/models/__init__.py"
      via: "Import all models for autogenerate detection"
      pattern: "from app.models import"
    - from: "backend/alembic/env.py"
      to: "backend/app/core/config.py"
      via: "DATABASE_URL for migrations"
      pattern: "settings\\.database_url"
    - from: "backend/app/models/report.py"
      to: "backend/app/models/base.py"
      via: "Inherits Base class"
      pattern: "class Report\\(Base\\)"
    - from: "backend/app/models/*.py"
      to: "backend/alembic/versions/001_initial_schema.py"
      via: "SQLAlchemy model definitions match migration table schemas"
      pattern: "CREATE TABLE.*tenants|users|templates|projects|reports|report_photos"
---

<objective>
Set up Alembic migrations with async configuration and create the complete initial database schema including PostGIS extension and all 6 core tables.

Purpose: Establish the database layer with proper migration tooling so all subsequent phases can add fields/tables incrementally.
Output: Alembic configured for async SQLAlchemy, all SQLAlchemy models defined, initial migration ready to run.
</objective>

<execution_context>
@C:\Users\xande\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\xande\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-setup-infrastructure/01-02-SUMMARY.md

Research findings (from planning context):
- Alembic: async env.py configuration needed for async SQLAlchemy
- PostGIS: CREATE EXTENSION must be in first migration before geometry columns
- Application-level tenant filtering for Phase 1 (RLS later)

Database schema from user's spec:
Tables: tenants, users, templates, projects, reports, report_photos
All with UUID primary keys, tenant_id foreign keys, created_at/updated_at timestamps
PostGIS extension for geographic data (location columns on reports and report_photos)
Triggers for updated_at auto-update
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Alembic for async SQLAlchemy</name>
  <files>
    backend/alembic.ini
    backend/alembic/env.py
    backend/alembic/script.py.mako
  </files>
  <action>
    1. Run `cd backend && alembic init alembic` to scaffold, then modify:

    2. alembic.ini:
       - Set sqlalchemy.url = (leave empty, will be overridden by env.py)
       - Set file_template = %%(year)d%%(month).2d%%(day).2d_%%(rev)s_%%(slug)s

    3. alembic/env.py (ASYNC version - critical):
       ```python
       import asyncio
       from logging.config import fileConfig
       from sqlalchemy import pool
       from sqlalchemy.ext.asyncio import async_engine_from_config
       from alembic import context

       from app.core.config import settings
       from app.models.base import Base
       # Import all models so autogenerate detects them
       from app.models import tenant, user, template, project, report, report_photo

       config = context.config
       config.set_main_option("sqlalchemy.url", settings.database_url)

       if config.config_file_name is not None:
           fileConfig(config.config_file_name)

       target_metadata = Base.metadata

       def run_migrations_offline():
           url = config.get_main_option("sqlalchemy.url")
           context.configure(url=url, target_metadata=target_metadata, literal_binds=True)
           with context.begin_transaction():
               context.run_migrations()

       def do_run_migrations(connection):
           context.configure(connection=connection, target_metadata=target_metadata)
           with context.begin_transaction():
               context.run_migrations()

       async def run_async_migrations():
           connectable = async_engine_from_config(
               config.get_section(config.config_ini_section, {}),
               prefix="sqlalchemy.",
               poolclass=pool.NullPool,
           )
           async with connectable.connect() as connection:
               await connection.run_sync(do_run_migrations)
           await connectable.dispose()

       def run_migrations_online():
           asyncio.run(run_async_migrations())

       if context.is_offline_mode():
           run_migrations_offline()
       else:
           run_migrations_online()
       ```

    4. Keep script.py.mako as default (Alembic init provides it)
  </action>
  <verify>
    cd backend && python -c "from alembic.config import Config; c = Config('alembic.ini'); print('Alembic config OK')"
  </verify>
  <done>Alembic configured with async engine, reads DATABASE_URL from settings, imports all models for autogenerate</done>
</task>

<task type="auto">
  <name>Task 2: Define SQLAlchemy models and create initial migration</name>
  <files>
    backend/app/models/tenant.py
    backend/app/models/user.py
    backend/app/models/template.py
    backend/app/models/project.py
    backend/app/models/report.py
    backend/app/models/report_photo.py
    backend/app/models/__init__.py
    backend/alembic/versions/001_initial_schema.py
  </files>
  <action>
    1. app/models/tenant.py - class Tenant(Base):
       - __tablename__ = "tenants"
       - Override: id (UUID, pk, no tenant_id on this table itself)
       - name: Mapped[str] = mapped_column(String(255), nullable=False)
       - slug: Mapped[str] = mapped_column(String(100), unique=True, nullable=False)
       - is_active: Mapped[bool] = mapped_column(default=True)
       - Note: Tenant does NOT inherit tenant_id from Base. Override or use separate base.

    2. app/models/user.py - class User(Base):
       - __tablename__ = "users"
       - email: Mapped[str] = mapped_column(String(255), unique=True, nullable=False)
       - password_hash: Mapped[str] = mapped_column(String(255), nullable=False)
       - full_name: Mapped[str] = mapped_column(String(255), nullable=False)
       - role: Mapped[str] = mapped_column(String(50), default="technician")
       - is_active: Mapped[bool] = mapped_column(default=True)
       - tenant_id FK to tenants.id

    3. app/models/template.py - class Template(Base):
       - __tablename__ = "templates"
       - name: Mapped[str] = mapped_column(String(255), nullable=False)
       - description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
       - schema_json: Mapped[str] = mapped_column(Text, nullable=False) (JSON as text)
       - is_active: Mapped[bool] = mapped_column(default=True)
       - tenant_id FK to tenants.id

    4. app/models/project.py - class Project(Base):
       - __tablename__ = "projects"
       - name: Mapped[str] = mapped_column(String(255), nullable=False)
       - description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
       - client_name: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
       - is_active: Mapped[bool] = mapped_column(default=True)
       - tenant_id FK to tenants.id

    5. app/models/report.py - class Report(Base):
       - __tablename__ = "reports"
       - title: Mapped[str] = mapped_column(String(255), nullable=False)
       - status: Mapped[str] = mapped_column(String(50), default="draft")
       - data_json: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
       - location: Mapped[Optional[str]] = mapped_column(Text, nullable=True) (store as WKT text for Phase 1, PostGIS geometry later)
       - template_id: FK to templates.id
       - project_id: FK to projects.id
       - user_id: FK to users.id (the technician)
       - tenant_id FK to tenants.id

    6. app/models/report_photo.py - class ReportPhoto(Base):
       - __tablename__ = "report_photos"
       - report_id: FK to reports.id
       - file_key: Mapped[str] = mapped_column(String(500), nullable=False) (R2 object key)
       - original_filename: Mapped[str] = mapped_column(String(255), nullable=False)
       - mime_type: Mapped[str] = mapped_column(String(100), nullable=False)
       - file_size_bytes: Mapped[int] = mapped_column(nullable=False)
       - location: Mapped[Optional[str]] = mapped_column(Text, nullable=True) (geolocated photo position)
       - watermark_applied: Mapped[bool] = mapped_column(default=False)
       - caption: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
       - tenant_id FK to tenants.id

    7. app/models/__init__.py:
       - Import all models so Alembic's autogenerate finds them:
         ```python
         from app.models.tenant import Tenant
         from app.models.user import User
         from app.models.template import Template
         from app.models.project import Project
         from app.models.report import Report
         from app.models.report_photo import ReportPhoto
         ```

    8. Create initial migration MANUALLY (don't run autogenerate since no DB available):
       backend/alembic/versions/001_initial_schema.py:
       - revision = "001"
       - down_revision = None
       - upgrade():
         - op.execute("CREATE EXTENSION IF NOT EXISTS postgis") (first!)
         - Create all 6 tables with proper columns, FKs, indexes
         - Create index on tenant_id for each table
         - Create trigger for updated_at auto-update
       - downgrade():
         - Drop tables in reverse FK order
         - op.execute("DROP EXTENSION IF EXISTS postgis")

    IMPORTANT: For Phase 1, use Text columns for location instead of Geometry type.
    PostGIS geometry columns will be added in a later migration when GIS features are needed.
    This avoids requiring PostGIS for local development.
  </action>
  <verify>
    cd backend && python -c "from app.models import Tenant, User, Template, Project, Report, ReportPhoto; print('All models import OK')"
    python -c "from app.models.base import Base; print(f'Tables: {list(Base.metadata.tables.keys())}')"
    Expected output: Tables: ['tenants', 'users', 'templates', 'projects', 'reports', 'report_photos']
  </verify>
  <done>All 6 models defined with proper relationships, initial migration created with PostGIS extension, autogenerate will detect future changes</done>
</task>

</tasks>

<verification>
1. All model files exist and import without errors
2. Base.metadata.tables contains all 6 table names
3. alembic/env.py imports all models
4. Initial migration file exists with CREATE EXTENSION postgis
5. Migration has proper upgrade/downgrade functions
6. `python -c "from app.models import *"` succeeds
</verification>

<success_criteria>
- Alembic configured for async SQLAlchemy 2.0
- All 6 SQLAlchemy models defined with proper columns and relationships
- Initial migration creates PostGIS extension + all tables
- Models have UUID PKs, tenant_id FKs, timestamps
- autogenerate can detect future model changes
</success_criteria>

<output>
After completion, create `.planning/phases/01-setup-infrastructure/01-03-SUMMARY.md`
</output>
