---
phase: 05-template-configuration
plan: 04
type: execute
wave: 3
depends_on: ["05-02", "05-03"]
files_modified:
  - frontend/src/types/template.ts
  - frontend/src/api/templates.ts
  - frontend/src/components/templates/AccordionSection.tsx
  - frontend/src/components/templates/InfoFieldsConfigurator.tsx
  - frontend/src/pages/TemplateConfigPage.tsx
  - frontend/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can navigate to template configuration page from template list"
    - "Configuration page shows accordion sections for info fields, checklist, and signatures"
    - "Admin can add, edit, and remove info fields dynamically"
    - "Info field changes persist to backend via API calls"
    - "useFieldArray manages dynamic info field list with proper key handling"
  artifacts:
    - path: "frontend/src/components/templates/AccordionSection.tsx"
      provides: "Reusable accordion component for config sections"
      min_lines: 25
    - path: "frontend/src/components/templates/InfoFieldsConfigurator.tsx"
      provides: "Dynamic form for managing info fields"
      min_lines: 80
    - path: "frontend/src/pages/TemplateConfigPage.tsx"
      provides: "Main configuration page with accordion layout"
      min_lines: 60
  key_links:
    - from: "frontend/src/components/templates/InfoFieldsConfigurator.tsx"
      to: "React Hook Form useFieldArray"
      via: "Dynamic field management"
      pattern: "useFieldArray"
    - from: "frontend/src/pages/TemplateConfigPage.tsx"
      to: "API endpoints"
      via: "React Query mutations"
      pattern: "useMutation"
---

<objective>
Create frontend template configuration UI with accordion layout and info fields management. Admins can view template structure and dynamically add/edit/remove info fields.

Purpose: Provide admin interface for configuring template metadata fields (project name, date, location, etc.) that appear at the top of reports.

Output: AccordionSection component, InfoFieldsConfigurator with useFieldArray, TemplateConfigPage with accordion layout, updated routing.
</objective>

<execution_context>
@C:\Users\xande\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\xande\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-template-configuration/05-RESEARCH.md
@.planning/phases/05-template-configuration/05-02-SUMMARY.md
@.planning/phases/05-template-configuration/05-03-SUMMARY.md

# Existing UI patterns
@frontend/src/pages/TemplatesPage.tsx
@frontend/src/components/templates/TemplateList.tsx
@frontend/src/api/templates.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript types and API functions for configuration</name>
  <files>
    frontend/src/types/template.ts
    frontend/src/api/templates.ts
  </files>
  <action>
**Extend template.ts types:**

```typescript
// Info field types
export interface InfoField {
  id: string
  template_id: string
  label: string
  field_type: 'text' | 'date' | 'select'
  options: string[] | null
  required: boolean
  order: number
  created_at: string
  updated_at: string
}

export interface InfoFieldCreate {
  label: string
  field_type: 'text' | 'date' | 'select'
  options?: string[]
  required: boolean
}

export interface InfoFieldUpdate {
  label?: string
  field_type?: 'text' | 'date' | 'select'
  options?: string[]
  required?: boolean
}

// Signature field types
export interface SignatureField {
  id: string
  template_id: string
  role_name: string
  required: boolean
  order: number
  created_at: string
  updated_at: string
}

export interface SignatureFieldCreate {
  role_name: string
  required: boolean
}

// Field configuration types
export interface PhotoConfig {
  required: boolean
  min_count: number
  max_count: number
  require_gps: boolean
  watermark: boolean
}

export interface CommentConfig {
  enabled: boolean
  required: boolean
}
```

**Add API functions to templates.ts:**

```typescript
// Info fields API
export const getInfoFields = (templateId: string) =>
  api.get<{ info_fields: InfoField[]; total: number }>(
    `/templates/${templateId}/info-fields`
  )

export const createInfoField = (templateId: string, data: InfoFieldCreate) =>
  api.post<InfoField>(`/templates/${templateId}/info-fields`, data)

export const updateInfoField = (
  templateId: string,
  fieldId: string,
  data: InfoFieldUpdate
) => api.patch<InfoField>(`/templates/${templateId}/info-fields/${fieldId}`, data)

export const deleteInfoField = (templateId: string, fieldId: string) =>
  api.delete(`/templates/${templateId}/info-fields/${fieldId}`)

export const reorderInfoFields = (templateId: string, fieldIds: string[]) =>
  api.put(`/templates/${templateId}/info-fields/reorder`, { field_ids: fieldIds })
```
  </action>
  <verify>
Run: `cd frontend && npx tsc --noEmit`
TypeScript should compile without errors.
  </verify>
  <done>
TypeScript types exist for InfoField, SignatureField, PhotoConfig, CommentConfig. API functions for info field CRUD operations added.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AccordionSection and InfoFieldsConfigurator components</name>
  <files>
    frontend/src/components/templates/AccordionSection.tsx
    frontend/src/components/templates/InfoFieldsConfigurator.tsx
  </files>
  <action>
**Create AccordionSection.tsx:**

Reusable accordion component with:
- Title prop
- defaultOpen prop (boolean)
- children slot
- Chevron icon that rotates on open/close
- Smooth expand/collapse animation using Tailwind

```typescript
interface AccordionSectionProps {
  title: string
  defaultOpen?: boolean
  children: React.ReactNode
  badge?: string | number  // Optional badge showing count
}
```

Use Tailwind for styling:
- Border and rounded corners
- Hover state on header
- Transition for chevron rotation

**Create InfoFieldsConfigurator.tsx:**

Dynamic form using useFieldArray from react-hook-form:

```typescript
interface InfoFieldsConfiguratorProps {
  templateId: string
  initialFields: InfoField[]
  onUpdate: () => void  // Callback to refresh parent data
}
```

Features:
- useFieldArray with keyName: 'key' to avoid id conflicts
- Each field row has: label input, field_type select, required checkbox, options input (for select type), delete button
- "Add Field" button appends new field with complete defaults
- Save changes button triggers API calls for modifications
- Use React Query useMutation for API calls with proper error handling
- Show loading states during save

Key implementation details from RESEARCH.md:
- Use field.key as React key (not index!)
- Provide complete default values when appending
- Conditional options input based on field_type
  </action>
  <verify>
Run: `cd frontend && npx tsc --noEmit`
Components should compile without TypeScript errors.
  </verify>
  <done>
AccordionSection component provides collapsible sections. InfoFieldsConfigurator uses useFieldArray for dynamic field management with proper key handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create TemplateConfigPage and add routing</name>
  <files>
    frontend/src/pages/TemplateConfigPage.tsx
    frontend/src/App.tsx
  </files>
  <action>
**Create TemplateConfigPage.tsx:**

Configuration page layout:
- Fetch template data with sections/fields using existing getTemplate API
- Fetch info fields using new getInfoFields API
- Fetch signature fields using new getSignatureFields API (add to templates.ts if not done)
- Use React Query useQuery for data fetching

Layout:
- Back button to template list
- Template name/code header
- Three AccordionSection components:
  1. "Info Fields" (defaultOpen=true) - InfoFieldsConfigurator
  2. "Checklist Sections" - Read-only display of sections/fields for now (Plan 05 will add config)
  3. "Signature Fields" - Placeholder for Plan 05

```typescript
export function TemplateConfigPage() {
  const { templateId } = useParams<{ templateId: string }>()
  const navigate = useNavigate()

  const { data: template, refetch: refetchTemplate } = useQuery({
    queryKey: ['template', templateId],
    queryFn: () => getTemplate(templateId!),
  })

  const { data: infoFields, refetch: refetchInfoFields } = useQuery({
    queryKey: ['infoFields', templateId],
    queryFn: () => getInfoFields(templateId!),
  })

  // ... render with accordions
}
```

**Update App.tsx routing:**

Add protected route:
```typescript
<Route
  path="/templates/:templateId/configure"
  element={
    <ProtectedRoute allowedRoles={['admin', 'superadmin']}>
      <TemplateConfigPage />
    </ProtectedRoute>
  }
/>
```

**Update TemplateList or TemplatesPage:**
Add "Configure" button/link to each template row that navigates to `/templates/${id}/configure`
  </action>
  <verify>
1. Run: `cd frontend && npm run build`
2. Start frontend and navigate to /templates/{id}/configure
3. Verify accordion sections render
  </verify>
  <done>
TemplateConfigPage renders with accordion layout. Route added and accessible from template list. Info fields accordion shows InfoFieldsConfigurator.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Route /templates/:templateId/configure exists and is protected
3. AccordionSection expands/collapses with animation
4. InfoFieldsConfigurator shows existing info fields
5. Can add new info field with all required defaults
6. Can edit field label, type, options, required
7. Can delete info field
8. Changes persist to backend (verify with network tab)
</verification>

<success_criteria>
- TemplateConfigPage accessible at /templates/:id/configure for admin/superadmin
- Accordion sections for Info Fields, Checklist, Signatures
- InfoFieldsConfigurator uses useFieldArray with field.key as React key
- Add/edit/delete info fields work with API persistence
- Field type "select" shows options input
- Loading and error states displayed appropriately
</success_criteria>

<output>
After completion, create `.planning/phases/05-template-configuration/05-04-SUMMARY.md`
</output>
