---
phase: 05-template-configuration
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - backend/app/schemas/template_signature_field.py
  - backend/app/schemas/template_field_config.py
  - backend/app/api/v1/routes/template_signature_fields.py
  - backend/app/api/v1/routes/template_field_config.py
  - backend/app/api/v1/router.py
autonomous: true

must_haves:
  truths:
    - "Admin can create signature fields for a template via POST endpoint"
    - "Admin can list, update, delete, and reorder signature fields"
    - "Admin can update photo_config and comment_config on a checklist field"
    - "JSONB mutation tracking uses flag_modified for proper persistence"
    - "PhotoConfig validates min_count <= max_count"
  artifacts:
    - path: "backend/app/schemas/template_signature_field.py"
      provides: "Pydantic schemas for signature field CRUD"
      min_lines: 35
    - path: "backend/app/schemas/template_field_config.py"
      provides: "Pydantic schemas for photo/comment config"
      min_lines: 30
    - path: "backend/app/api/v1/routes/template_signature_fields.py"
      provides: "FastAPI router for signature fields"
      min_lines: 100
    - path: "backend/app/api/v1/routes/template_field_config.py"
      provides: "FastAPI router for field configuration"
      min_lines: 50
  key_links:
    - from: "backend/app/api/v1/routes/template_field_config.py"
      to: "TemplateField model"
      via: "flag_modified for JSONB mutation tracking"
      pattern: "flag_modified"
    - from: "backend/app/api/v1/router.py"
      to: "signature_fields and field_config routers"
      via: "router.include_router"
      pattern: "include_router"
---

<objective>
Create backend API endpoints for signature fields CRUD and checklist field configuration (photo/comment settings).

Purpose: Enable admins to define who must sign reports (signature fields) and configure per-field photo/comment requirements on checklist items.

Output: Pydantic schemas for signature fields and field config, two FastAPI routers for signature CRUD and field config updates.
</objective>

<execution_context>
@C:\Users\xande\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\xande\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-template-configuration/05-RESEARCH.md
@.planning/phases/05-template-configuration/05-01-SUMMARY.md

# Patterns to follow
@backend/app/api/v1/routes/templates.py
@backend/app/schemas/template.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create signature field schemas and API router</name>
  <files>
    backend/app/schemas/template_signature_field.py
    backend/app/api/v1/routes/template_signature_fields.py
  </files>
  <action>
**Create template_signature_field.py schemas:**

```python
"""Pydantic schemas for template signature field API."""
from datetime import datetime
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field


class SignatureFieldCreate(BaseModel):
    """Schema for creating a signature field."""
    role_name: str = Field(..., min_length=1, max_length=100)
    required: bool = True


class SignatureFieldUpdate(BaseModel):
    """Schema for updating a signature field."""
    role_name: str | None = Field(None, min_length=1, max_length=100)
    required: bool | None = None


class SignatureFieldResponse(BaseModel):
    """Schema for signature field response."""
    model_config = ConfigDict(from_attributes=True)

    id: UUID
    template_id: UUID
    role_name: str
    required: bool
    order: int
    created_at: datetime
    updated_at: datetime


class SignatureFieldListResponse(BaseModel):
    """Schema for list of signature fields."""
    signature_fields: list[SignatureFieldResponse]
    total: int


class SignatureFieldReorder(BaseModel):
    """Schema for reordering signature fields."""
    field_ids: list[UUID] = Field(..., min_length=1)
```

**Create template_signature_fields.py router:**

Same pattern as info fields router:
- POST /templates/{template_id}/signature-fields - Create with auto-order
- GET /templates/{template_id}/signature-fields - List ordered
- PATCH /templates/{template_id}/signature-fields/{field_id} - Update
- DELETE /templates/{template_id}/signature-fields/{field_id} - Delete
- PUT /templates/{template_id}/signature-fields/reorder - Reorder

All endpoints require admin/superadmin role and use tenant filtering via template ownership check.
  </action>
  <verify>
Run: `python -c "from app.schemas.template_signature_field import SignatureFieldCreate; from app.api.v1.routes.template_signature_fields import router; print('Signature endpoints loaded')"`
  </verify>
  <done>
Signature field schemas and router exist with 5 CRUD + reorder endpoints following info fields pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create field configuration schemas and API endpoint</name>
  <files>
    backend/app/schemas/template_field_config.py
    backend/app/api/v1/routes/template_field_config.py
    backend/app/api/v1/router.py
  </files>
  <action>
**Create template_field_config.py schemas:**

```python
"""Pydantic schemas for checklist field configuration."""
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field, model_validator


class PhotoConfig(BaseModel):
    """Photo configuration for a checklist field."""
    required: bool = False
    min_count: int = Field(default=0, ge=0)
    max_count: int = Field(default=10, ge=1, le=20)
    require_gps: bool = False
    watermark: bool = True

    @model_validator(mode="after")
    def validate_counts(self):
        if self.min_count > self.max_count:
            raise ValueError("min_count cannot exceed max_count")
        return self


class CommentConfig(BaseModel):
    """Comment configuration for a checklist field."""
    enabled: bool = True
    required: bool = False


class FieldConfigUpdate(BaseModel):
    """Schema for updating field configuration."""
    photo_config: PhotoConfig | None = None
    comment_config: CommentConfig | None = None


class FieldConfigResponse(BaseModel):
    """Schema for field with configuration."""
    model_config = ConfigDict(from_attributes=True)

    id: UUID
    label: str
    field_type: str
    photo_config: PhotoConfig | None
    comment_config: CommentConfig | None
```

**Create template_field_config.py router:**

Single endpoint for updating field configuration:

**PATCH /templates/fields/{field_id}/config**
- Verify field exists by joining TemplateField -> TemplateSection -> Template
- Verify template belongs to tenant via get_tenant_filter
- Update JSONB columns using flag_modified for proper mutation tracking:
```python
from sqlalchemy.orm.attributes import flag_modified

if data.photo_config is not None:
    field.photo_config = data.photo_config.model_dump()
    flag_modified(field, 'photo_config')

if data.comment_config is not None:
    field.comment_config = data.comment_config.model_dump()
    flag_modified(field, 'comment_config')
```
- Return updated field with config

**Register both new routers in router.py:**
```python
from app.api.v1.routes.template_signature_fields import router as signature_fields_router
from app.api.v1.routes.template_field_config import router as field_config_router

router.include_router(signature_fields_router)
router.include_router(field_config_router)
```
  </action>
  <verify>
Run: `python -c "from app.schemas.template_field_config import PhotoConfig, FieldConfigUpdate; from app.api.v1.routes.template_field_config import router; print('Field config endpoints loaded')"`
  </verify>
  <done>
Field configuration schemas with validation exist. PATCH endpoint updates photo_config and comment_config with proper JSONB mutation tracking. Both new routers registered.
  </done>
</task>

</tasks>

<verification>
1. Signature field schemas validate role_name length and required flag
2. Signature field router has 5 endpoints matching info fields pattern
3. PhotoConfig validates min_count <= max_count
4. Field config endpoint uses flag_modified for JSONB persistence
5. Both routers registered in main API router
6. All endpoints enforce admin/superadmin role
</verification>

<success_criteria>
- SignatureFieldCreate/Update/Response schemas exist with proper validation
- POST/GET/PATCH/DELETE/PUT endpoints for signature fields work
- PhotoConfig schema enforces min_count <= max_count
- CommentConfig schema has enabled and required flags
- PATCH /templates/fields/{id}/config updates JSONB columns correctly
- flag_modified used for JSONB mutation tracking
- All endpoints have tenant isolation via template ownership check
</success_criteria>

<output>
After completion, create `.planning/phases/05-template-configuration/05-03-SUMMARY.md`
</output>
