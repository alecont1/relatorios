---
phase: 05-template-configuration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - backend/app/schemas/template_info_field.py
  - backend/app/api/v1/routes/template_info_fields.py
  - backend/app/api/v1/router.py
autonomous: true

must_haves:
  truths:
    - "Admin can create info fields for a template via POST endpoint"
    - "Admin can list all info fields for a template via GET endpoint"
    - "Admin can update an info field via PATCH endpoint"
    - "Admin can delete an info field via DELETE endpoint"
    - "Admin can reorder info fields via PUT endpoint"
    - "Info field validation enforces field_type values (text, date, select)"
  artifacts:
    - path: "backend/app/schemas/template_info_field.py"
      provides: "Pydantic schemas for info field CRUD"
      min_lines: 40
    - path: "backend/app/api/v1/routes/template_info_fields.py"
      provides: "FastAPI router with CRUD endpoints"
      min_lines: 100
  key_links:
    - from: "backend/app/api/v1/routes/template_info_fields.py"
      to: "TemplateInfoField model"
      via: "SQLAlchemy queries with tenant filtering"
      pattern: "select.*TemplateInfoField"
    - from: "backend/app/api/v1/router.py"
      to: "template_info_fields router"
      via: "router.include_router"
      pattern: "include_router.*template_info_fields"
---

<objective>
Create backend API endpoints for managing template info fields. Info fields capture project-level metadata (project name, date, location, etc.) displayed at the top of reports.

Purpose: Enable admins to configure what metadata fields appear on each template for capturing project information.

Output: Pydantic schemas for validation, FastAPI router with CRUD + reorder endpoints.
</objective>

<execution_context>
@C:\Users\xande\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\xande\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-template-configuration/05-RESEARCH.md
@.planning/phases/05-template-configuration/05-01-SUMMARY.md

# Existing patterns to follow
@backend/app/api/v1/routes/templates.py
@backend/app/schemas/template.py
@backend/app/core/deps.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas for info fields</name>
  <files>
    backend/app/schemas/template_info_field.py
  </files>
  <action>
Create new schema file with validation for info field CRUD operations:

```python
"""Pydantic schemas for template info field API."""
from datetime import datetime
from typing import Literal
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field, field_validator


class InfoFieldCreate(BaseModel):
    """Schema for creating an info field."""
    label: str = Field(..., min_length=1, max_length=255)
    field_type: Literal["text", "date", "select"]
    options: list[str] | None = None
    required: bool = True

    @field_validator("options")
    @classmethod
    def validate_options(cls, v, info):
        """Ensure options provided for select type."""
        field_type = info.data.get("field_type")
        if field_type == "select" and not v:
            raise ValueError("options are required for select field_type")
        if field_type != "select" and v:
            raise ValueError("options only allowed for select field_type")
        return v


class InfoFieldUpdate(BaseModel):
    """Schema for updating an info field."""
    label: str | None = Field(None, min_length=1, max_length=255)
    field_type: Literal["text", "date", "select"] | None = None
    options: list[str] | None = None
    required: bool | None = None


class InfoFieldResponse(BaseModel):
    """Schema for info field response."""
    model_config = ConfigDict(from_attributes=True)

    id: UUID
    template_id: UUID
    label: str
    field_type: str
    options: list[str] | None
    required: bool
    order: int
    created_at: datetime
    updated_at: datetime


class InfoFieldListResponse(BaseModel):
    """Schema for list of info fields."""
    info_fields: list[InfoFieldResponse]
    total: int


class InfoFieldReorder(BaseModel):
    """Schema for reordering info fields."""
    field_ids: list[UUID] = Field(..., min_length=1)
```
  </action>
  <verify>
Run: `python -c "from app.schemas.template_info_field import InfoFieldCreate, InfoFieldResponse; print('Schemas imported')"`
  </verify>
  <done>
Pydantic schemas exist for InfoFieldCreate, InfoFieldUpdate, InfoFieldResponse, InfoFieldListResponse, and InfoFieldReorder with proper validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create info fields API router with CRUD endpoints</name>
  <files>
    backend/app/api/v1/routes/template_info_fields.py
    backend/app/api/v1/router.py
  </files>
  <action>
Create router with these endpoints (all require admin/superadmin role):

**POST /templates/{template_id}/info-fields**
- Verify template exists and belongs to tenant
- Get max order, create field with order = max + 1
- Return created field

**GET /templates/{template_id}/info-fields**
- List all info fields for template, ordered by order field
- Return InfoFieldListResponse

**PATCH /templates/{template_id}/info-fields/{field_id}**
- Verify field exists and template belongs to tenant
- Update provided fields
- If changing to/from select type, validate options accordingly
- Return updated field

**DELETE /templates/{template_id}/info-fields/{field_id}**
- Verify field exists and template belongs to tenant
- Delete field
- Return 204 No Content

**PUT /templates/{template_id}/info-fields/reorder**
- Accept list of field_ids in desired order
- Verify all IDs belong to this template
- Update order field for each (1, 2, 3...)
- Return updated list

Key patterns:
- Use `get_tenant_filter` dependency for tenant isolation
- Verify template ownership before any field operation
- Parse options JSON string when reading from DB
- Store options as JSON string in DB

Register router in `router.py`:
```python
from app.api.v1.routes.template_info_fields import router as info_fields_router
router.include_router(info_fields_router)
```
  </action>
  <verify>
Run backend and test with curl:
```bash
# Start server
cd backend && uvicorn app.main:app --reload &

# Test endpoint exists (will 401 without auth, but route should exist)
curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/api/v1/templates/00000000-0000-0000-0000-000000000000/info-fields
# Should return 401 or 404, not 404 for the route itself
```
  </verify>
  <done>
Info fields router has 5 endpoints (create, list, update, delete, reorder) with proper tenant isolation, admin role requirement, and validation.
  </done>
</task>

</tasks>

<verification>
1. Schemas import without errors
2. All 5 endpoints exist and respond (401/404 for invalid auth/template is OK)
3. Router is registered in main API router
4. Create endpoint auto-generates order
5. Reorder endpoint validates all IDs belong to template
6. Options validation enforces select type requirement
</verification>

<success_criteria>
- InfoFieldCreate schema validates field_type (text, date, select) and options
- InfoFieldResponse includes all fields including order
- POST /templates/{id}/info-fields creates field with auto-incremented order
- GET /templates/{id}/info-fields returns ordered list
- PATCH /templates/{id}/info-fields/{id} updates field properties
- DELETE /templates/{id}/info-fields/{id} removes field
- PUT /templates/{id}/info-fields/reorder updates order values
- All endpoints enforce admin/superadmin role and tenant isolation
</success_criteria>

<output>
After completion, create `.planning/phases/05-template-configuration/05-02-SUMMARY.md`
</output>
