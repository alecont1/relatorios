---
phase: 04-template-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/template.py
  - backend/app/models/template_section.py
  - backend/app/models/template_field.py
  - backend/app/models/__init__.py
  - backend/alembic/versions/20260131_003_template_tables.py
  - backend/app/schemas/template.py
autonomous: true

must_haves:
  truths:
    - "Template model exists with name, code, category, version, is_active fields"
    - "TemplateSection model exists with name, order, template relationship"
    - "TemplateField model exists with label, field_type, options, order, section relationship"
    - "Migration creates all three tables with proper foreign keys"
    - "Pydantic schemas exist for API request/response"
  artifacts:
    - path: "backend/app/models/template.py"
      provides: "Template model with metadata and header fields"
      contains: "class Template"
    - path: "backend/app/models/template_section.py"
      provides: "TemplateSection model with ordering"
      contains: "class TemplateSection"
    - path: "backend/app/models/template_field.py"
      provides: "TemplateField model with field_type and options"
      contains: "class TemplateField"
    - path: "backend/alembic/versions/20260131_003_template_tables.py"
      provides: "Migration for template tables"
      contains: "create_table"
    - path: "backend/app/schemas/template.py"
      provides: "Pydantic schemas for template API"
      contains: "TemplateCreate"
  key_links:
    - from: "backend/app/models/template_section.py"
      to: "backend/app/models/template.py"
      via: "ForeignKey relationship"
      pattern: "ForeignKey.*templates.id"
    - from: "backend/app/models/template_field.py"
      to: "backend/app/models/template_section.py"
      via: "ForeignKey relationship"
      pattern: "ForeignKey.*template_sections.id"
---

<objective>
Create database models and migration for template management system.

Purpose: Templates are the foundation for report generation. This plan establishes the data layer with Template (metadata + header), TemplateSection (groups of fields), and TemplateField (checklist items) models, plus Pydantic schemas for the API.

Output: Three SQLAlchemy models, one Alembic migration, and Pydantic schemas ready for API endpoints.
</objective>

<execution_context>
@C:\Users\xande\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\xande\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:\Users\xande\smarthand-reports\.planning\PROJECT.md
@C:\Users\xande\smarthand-reports\.planning\ROADMAP.md
@C:\Users\xande\smarthand-reports\.planning\STATE.md
@C:\Users\xande\smarthand-reports\.planning\phases\04-template-management\04-CONTEXT.md
@C:\Users\xande\smarthand-reports\.planning\phases\04-template-management\04-RESEARCH.md

# Existing patterns
@C:\Users\xande\smarthand-reports\backend\app\models\base.py
@C:\Users\xande\smarthand-reports\backend\app\models\tenant.py
@C:\Users\xande\smarthand-reports\backend\app\schemas\tenant.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Template, TemplateSection, and TemplateField models</name>
  <files>
    backend/app/models/template.py
    backend/app/models/template_section.py
    backend/app/models/template_field.py
    backend/app/models/__init__.py
  </files>
  <action>
    **Replace** existing template.py stub with full Template model:
    - Inherits from Base (gets id, tenant_id, created_at, updated_at automatically)
    - Fields: name (String 255), code (String 50, unique per tenant), category (String 50), version (Integer default 1)
    - Header fields: title (String 500 nullable), reference_standards (Text nullable), planning_requirements (Text nullable)
    - is_active (Boolean default True)
    - Relationship: sections (one-to-many with cascade delete-orphan)
    - Add unique constraint on (tenant_id, code) combination

    **Create** template_section.py:
    - Inherits from Base (but override tenant_id to be nullable since section belongs to template which has tenant_id)
    - Actually: TemplateSection does NOT need tenant_id since it belongs to Template which already has it
    - Use a simpler base without tenant_id: Create TemplateSection inheriting from DeclarativeBase directly or use a non-tenant Base
    - Fields: template_id (UUID FK to templates.id), name (String 255), order (Integer)
    - Relationships: template (back_populates sections), fields (one-to-many with cascade)

    **Create** template_field.py:
    - Same approach - no tenant_id since it belongs to section -> template
    - Fields: section_id (UUID FK to template_sections.id), label (String 500), field_type (String 50), options (Text nullable for JSON), order (Integer)
    - Relationship: section (back_populates fields)

    **Pattern for non-tenant models:** Create a simple base class or inherit from DeclarativeBase directly with just id and timestamps, since these child tables get tenant isolation through their parent Template.

    **Update** __init__.py to export all three models.
  </action>
  <verify>
    Run: cd C:\Users\xande\smarthand-reports\backend && python -c "from app.models.template import Template; from app.models.template_section import TemplateSection; from app.models.template_field import TemplateField; print('Models import OK')"
  </verify>
  <done>
    - Template model has name, code, category, version, title, reference_standards, planning_requirements, is_active
    - TemplateSection model has template_id, name, order with relationship to Template
    - TemplateField model has section_id, label, field_type, options, order with relationship to TemplateSection
    - All models exportable from app.models
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Alembic migration for template tables</name>
  <files>
    backend/alembic/versions/20260131_003_template_tables.py
  </files>
  <action>
    Create manual migration file (not autogenerate - more control):

    **Migration steps:**
    1. Drop existing templates table if exists (the stub from Phase 1)
    2. Create new templates table with all fields:
       - id UUID primary key
       - tenant_id UUID NOT NULL with FK to tenants.id and index
       - name VARCHAR(255) NOT NULL
       - code VARCHAR(50) NOT NULL
       - category VARCHAR(50) NOT NULL
       - version INTEGER DEFAULT 1
       - title VARCHAR(500) nullable
       - reference_standards TEXT nullable
       - planning_requirements TEXT nullable
       - is_active BOOLEAN DEFAULT TRUE
       - created_at, updated_at TIMESTAMP defaults
       - UNIQUE constraint on (tenant_id, code)

    3. Create template_sections table:
       - id UUID primary key
       - template_id UUID NOT NULL with FK to templates.id (ondelete CASCADE)
       - name VARCHAR(255) NOT NULL
       - order INTEGER NOT NULL
       - created_at, updated_at TIMESTAMP

    4. Create template_fields table:
       - id UUID primary key
       - section_id UUID NOT NULL with FK to template_sections.id (ondelete CASCADE)
       - label VARCHAR(500) NOT NULL
       - field_type VARCHAR(50) NOT NULL
       - options TEXT nullable
       - order INTEGER NOT NULL
       - created_at, updated_at TIMESTAMP

    **Downgrade:** Drop template_fields, template_sections, then recreate old templates stub.

    Set revision to depend on 20260131_002_tenant_branding (previous migration).
  </action>
  <verify>
    Run: cd C:\Users\xande\smarthand-reports\backend && alembic upgrade head
    Then: alembic downgrade -1 && alembic upgrade head (verify reversibility)
  </verify>
  <done>
    - Migration runs successfully creating all three tables
    - Foreign key constraints work (sections cascade delete with template, fields cascade with section)
    - Unique constraint on (tenant_id, code) prevents duplicate codes per tenant
    - Migration is reversible
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Pydantic schemas for template API</name>
  <files>
    backend/app/schemas/template.py
  </files>
  <action>
    Create comprehensive Pydantic schemas:

    **TemplateFieldCreate:**
    - label: str (min 1 char)
    - field_type: Literal["dropdown", "text"]
    - options: list[str] | None (required if field_type is dropdown)
    - order: int

    **TemplateSectionCreate:**
    - name: str (min 1 char)
    - fields: list[TemplateFieldCreate]
    - order: int

    **TemplateCreate:**
    - name: str (min 1, max 255)
    - category: Literal["Commissioning", "Inspection", "Maintenance", "Testing"]
    - sections: list[TemplateSectionCreate]
    - title: str | None
    - reference_standards: str | None
    - planning_requirements: str | None

    **TemplateUpdate:**
    - name: str | None
    - category: Literal[...] | None
    - is_active: bool | None
    - title: str | None
    - reference_standards: str | None
    - planning_requirements: str | None

    **TemplateFieldResponse:**
    - id: UUID
    - label: str
    - field_type: str
    - options: list[str] | None
    - order: int

    **TemplateSectionResponse:**
    - id: UUID
    - name: str
    - order: int
    - fields: list[TemplateFieldResponse]

    **TemplateResponse:**
    - id: UUID
    - tenant_id: UUID
    - name: str
    - code: str
    - category: str
    - version: int
    - title: str | None
    - reference_standards: str | None
    - planning_requirements: str | None
    - is_active: bool
    - created_at: datetime
    - updated_at: datetime
    - sections: list[TemplateSectionResponse] | None (optional for list view)

    **TemplateListItem:** (for list endpoint - no sections)
    - id, name, code, category, version, is_active, created_at

    **TemplateListResponse:**
    - templates: list[TemplateListItem]
    - total: int

    **ExcelParseResponse:** (for parse endpoint)
    - valid: bool
    - sections: list[TemplateSectionCreate] | None
    - errors: list[str] | None
    - summary: dict | None (section_count, field_count)

    Use model_config = ConfigDict(from_attributes=True) for ORM compatibility.
  </action>
  <verify>
    Run: cd C:\Users\xande\smarthand-reports\backend && python -c "from app.schemas.template import TemplateCreate, TemplateResponse, ExcelParseResponse; print('Schemas import OK')"
  </verify>
  <done>
    - All schemas importable without errors
    - TemplateCreate validates category as enum
    - TemplateFieldCreate validates options required for dropdown type
    - Response schemas have from_attributes=True for ORM
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. All models import correctly: `from app.models import Template, TemplateSection, TemplateField`
2. Migration is at head: `alembic current` shows 20260131_003
3. All schemas import correctly: `from app.schemas.template import *`
4. Database has templates, template_sections, template_fields tables
</verification>

<success_criteria>
- Template model with all required fields and tenant_id for isolation
- TemplateSection and TemplateField with proper relationships and cascade delete
- Unique constraint on (tenant_id, code) prevents duplicate template codes
- Migration creates all tables with correct foreign keys
- Pydantic schemas ready for API request/response validation
</success_criteria>

<output>
After completion, create `.planning/phases/04-template-management/04-01-SUMMARY.md`
</output>
