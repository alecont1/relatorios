---
phase: 04-template-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/requirements.txt
  - backend/app/services/excel_parser.py
  - backend/app/services/__init__.py
autonomous: true

must_haves:
  truths:
    - "openpyxl is installed and importable"
    - "Excel parser validates all rows and collects ALL errors (not fail-fast)"
    - "Parser returns structured preview with sections and fields"
    - "Invalid files return descriptive error messages with row numbers"
  artifacts:
    - path: "backend/requirements.txt"
      provides: "openpyxl dependency"
      contains: "openpyxl"
    - path: "backend/app/services/excel_parser.py"
      provides: "Excel parsing service"
      contains: "parse_template_excel"
  key_links:
    - from: "backend/app/services/excel_parser.py"
      to: "openpyxl"
      via: "import statement"
      pattern: "from openpyxl import"
---

<objective>
Create Excel parsing service for template import.

Purpose: Templates are created by uploading Excel files (matching existing workflow). This service parses the Excel, validates all rows, collects errors, and returns a structured preview. Validation is strict but user-friendly - all errors shown at once.

Output: A service function that takes Excel bytes and returns either a valid preview or a list of all errors.
</objective>

<execution_context>
@C:\Users\xande\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\xande\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:\Users\xande\smarthand-reports\.planning\PROJECT.md
@C:\Users\xande\smarthand-reports\.planning\phases\04-template-management\04-CONTEXT.md
@C:\Users\xande\smarthand-reports\.planning\phases\04-template-management\04-RESEARCH.md

# Existing service patterns
@C:\Users\xande\smarthand-reports\backend\app\services\storage.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add openpyxl dependency and create Excel parser service</name>
  <files>
    backend/requirements.txt
    backend/app/services/excel_parser.py
    backend/app/services/__init__.py
  </files>
  <action>
    **Add to requirements.txt:**
    ```
    openpyxl>=3.1.0
    ```

    **Create excel_parser.py:**

    ```python
    """
    Excel parsing service for template import.

    Parses Excel files with expected format:
    | Section | Script Step | Result Type | Step Result Values |

    Result Type: "Drop Down" or "Text"
    Step Result Values: comma or slash separated options for dropdowns (e.g., "Yes/No/NA")
    """

    from io import BytesIO
    from dataclasses import dataclass, field
    from openpyxl import load_workbook
    from openpyxl.utils.exceptions import InvalidFileException


    @dataclass
    class ParsedField:
        label: str
        field_type: str  # "dropdown" or "text"
        options: list[str] | None
        order: int


    @dataclass
    class ParsedSection:
        name: str
        fields: list[ParsedField] = field(default_factory=list)
        order: int = 0


    @dataclass
    class ParseResult:
        valid: bool
        sections: list[ParsedSection] | None = None
        errors: list[str] | None = None
        summary: dict | None = None


    def parse_template_excel(file_content: bytes) -> ParseResult:
        """
        Parse Excel file and return structured template data or errors.

        Expected columns (row 1 is header):
        A: Section - section name (required)
        B: Script Step - question/field label (required)
        C: Result Type - "Drop Down" or "Text" (required)
        D: Step Result Values - options for dropdown, comma or slash separated

        Args:
            file_content: Raw bytes of the uploaded Excel file

        Returns:
            ParseResult with either sections or errors
        """
        errors: list[str] = []

        # Try to load workbook
        try:
            wb = load_workbook(filename=BytesIO(file_content), read_only=True, data_only=True)
        except InvalidFileException:
            return ParseResult(valid=False, errors=["Arquivo Excel invalido ou corrompido"])
        except Exception as e:
            return ParseResult(valid=False, errors=[f"Erro ao abrir arquivo: {str(e)}"])

        sheet = wb.active
        if sheet is None:
            return ParseResult(valid=False, errors=["Arquivo Excel sem planilha ativa"])

        # Validate header row
        header_row = [cell for cell in next(sheet.iter_rows(min_row=1, max_row=1, values_only=True))]
        expected_headers = ["Section", "Script Step", "Result Type", "Step Result Values"]

        if len(header_row) < 4:
            errors.append(f"Cabecalho incompleto. Esperado: {', '.join(expected_headers)}")

        # Process data rows
        sections_dict: dict[str, ParsedSection] = {}
        field_order = 0
        section_order = 0

        for row_num, row in enumerate(sheet.iter_rows(min_row=2, values_only=True), start=2):
            # Skip completely empty rows
            if all(cell is None or str(cell).strip() == "" for cell in row[:4]):
                continue

            # Extract values (handle None gracefully)
            section_name = str(row[0]).strip() if row[0] else ""
            script_step = str(row[1]).strip() if len(row) > 1 and row[1] else ""
            result_type = str(row[2]).strip() if len(row) > 2 and row[2] else ""
            step_values = str(row[3]).strip() if len(row) > 3 and row[3] else ""

            # Validate required fields
            if not section_name:
                errors.append(f"Linha {row_num}: Coluna 'Section' e obrigatoria")

            if not script_step:
                errors.append(f"Linha {row_num}: Coluna 'Script Step' e obrigatoria")

            if not result_type:
                errors.append(f"Linha {row_num}: Coluna 'Result Type' e obrigatoria")
            elif result_type.lower() not in ["drop down", "dropdown", "text"]:
                errors.append(f"Linha {row_num}: 'Result Type' invalido '{result_type}'. Use 'Drop Down' ou 'Text'")

            # Validate dropdown options
            field_type = "dropdown" if result_type.lower() in ["drop down", "dropdown"] else "text"
            options: list[str] | None = None

            if field_type == "dropdown":
                if not step_values:
                    errors.append(f"Linha {row_num}: 'Step Result Values' e obrigatorio para tipo 'Drop Down'")
                else:
                    # Parse options (handle both / and , separators)
                    if "/" in step_values:
                        options = [opt.strip() for opt in step_values.split("/") if opt.strip()]
                    elif "," in step_values:
                        options = [opt.strip() for opt in step_values.split(",") if opt.strip()]
                    else:
                        options = [step_values.strip()]

                    if len(options) < 2:
                        errors.append(f"Linha {row_num}: 'Drop Down' precisa de pelo menos 2 opcoes")

            # If no errors for this row, add to structure
            if section_name and script_step and result_type:
                if section_name not in sections_dict:
                    sections_dict[section_name] = ParsedSection(
                        name=section_name,
                        order=section_order
                    )
                    section_order += 1

                sections_dict[section_name].fields.append(ParsedField(
                    label=script_step,
                    field_type=field_type,
                    options=options,
                    order=field_order
                ))
                field_order += 1

        wb.close()

        # Return result
        if errors:
            return ParseResult(valid=False, errors=errors)

        sections_list = list(sections_dict.values())

        if not sections_list:
            return ParseResult(valid=False, errors=["Nenhum dado encontrado no arquivo Excel"])

        # Calculate summary
        total_fields = sum(len(s.fields) for s in sections_list)

        return ParseResult(
            valid=True,
            sections=sections_list,
            summary={
                "section_count": len(sections_list),
                "field_count": total_fields
            }
        )
    ```

    **Update services/__init__.py:**
    Add export for excel_parser functions.
  </action>
  <verify>
    Run: cd C:\Users\xande\smarthand-reports\backend && pip install openpyxl && python -c "from app.services.excel_parser import parse_template_excel, ParseResult; print('Parser import OK')"
  </verify>
  <done>
    - openpyxl added to requirements.txt and installed
    - parse_template_excel function exists and is importable
    - ParseResult, ParsedSection, ParsedField dataclasses defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for Excel parser edge cases</name>
  <files>
    backend/tests/test_excel_parser.py
  </files>
  <action>
    Create comprehensive tests for the Excel parser:

    ```python
    """
    Unit tests for Excel template parser.

    Tests cover:
    - Valid Excel parsing
    - Missing required fields
    - Invalid result types
    - Dropdown without options
    - Empty files
    - Invalid file format
    """

    import pytest
    from io import BytesIO
    from openpyxl import Workbook

    from app.services.excel_parser import parse_template_excel, ParseResult


    def create_test_excel(rows: list[list]) -> bytes:
        """Helper to create Excel file bytes from row data."""
        wb = Workbook()
        ws = wb.active

        # Add header
        ws.append(["Section", "Script Step", "Result Type", "Step Result Values"])

        # Add data rows
        for row in rows:
            ws.append(row)

        buffer = BytesIO()
        wb.save(buffer)
        buffer.seek(0)
        return buffer.read()


    class TestExcelParser:
        def test_valid_excel_with_dropdown_and_text(self):
            """Test parsing valid Excel with mixed field types."""
            rows = [
                ["General", "Check power", "Drop Down", "Yes/No/NA"],
                ["General", "Serial number", "Text", ""],
                ["Electrical", "Voltage reading", "Text", ""],
            ]
            excel_bytes = create_test_excel(rows)

            result = parse_template_excel(excel_bytes)

            assert result.valid is True
            assert result.errors is None
            assert len(result.sections) == 2
            assert result.summary["section_count"] == 2
            assert result.summary["field_count"] == 3

            # Check first section
            general = result.sections[0]
            assert general.name == "General"
            assert len(general.fields) == 2
            assert general.fields[0].field_type == "dropdown"
            assert general.fields[0].options == ["Yes", "No", "NA"]
            assert general.fields[1].field_type == "text"

        def test_missing_section_column(self):
            """Test error when Section is empty."""
            rows = [
                ["", "Check power", "Drop Down", "Yes/No"],
            ]
            excel_bytes = create_test_excel(rows)

            result = parse_template_excel(excel_bytes)

            assert result.valid is False
            assert any("Section" in e and "obrigatoria" in e for e in result.errors)

        def test_missing_script_step(self):
            """Test error when Script Step is empty."""
            rows = [
                ["General", "", "Drop Down", "Yes/No"],
            ]
            excel_bytes = create_test_excel(rows)

            result = parse_template_excel(excel_bytes)

            assert result.valid is False
            assert any("Script Step" in e and "obrigatoria" in e for e in result.errors)

        def test_invalid_result_type(self):
            """Test error for invalid Result Type."""
            rows = [
                ["General", "Check", "Checkbox", "Yes/No"],
            ]
            excel_bytes = create_test_excel(rows)

            result = parse_template_excel(excel_bytes)

            assert result.valid is False
            assert any("Result Type" in e and "invalido" in e for e in result.errors)

        def test_dropdown_without_options(self):
            """Test error when Drop Down has no options."""
            rows = [
                ["General", "Check", "Drop Down", ""],
            ]
            excel_bytes = create_test_excel(rows)

            result = parse_template_excel(excel_bytes)

            assert result.valid is False
            assert any("Step Result Values" in e and "obrigatorio" in e for e in result.errors)

        def test_dropdown_with_single_option(self):
            """Test error when Drop Down has only one option."""
            rows = [
                ["General", "Check", "Drop Down", "Yes"],
            ]
            excel_bytes = create_test_excel(rows)

            result = parse_template_excel(excel_bytes)

            assert result.valid is False
            assert any("2 opcoes" in e for e in result.errors)

        def test_collects_all_errors(self):
            """Test that parser collects ALL errors, not just first."""
            rows = [
                ["", "Check", "Drop Down", ""],  # Missing section + missing options
                ["General", "", "InvalidType", ""],  # Missing step + invalid type
            ]
            excel_bytes = create_test_excel(rows)

            result = parse_template_excel(excel_bytes)

            assert result.valid is False
            # Should have at least 4 errors (not fail on first)
            assert len(result.errors) >= 4

        def test_comma_separated_options(self):
            """Test parsing comma-separated options."""
            rows = [
                ["General", "Status", "Drop Down", "Active, Inactive, Pending"],
            ]
            excel_bytes = create_test_excel(rows)

            result = parse_template_excel(excel_bytes)

            assert result.valid is True
            assert result.sections[0].fields[0].options == ["Active", "Inactive", "Pending"]

        def test_empty_excel(self):
            """Test error for Excel with only header."""
            excel_bytes = create_test_excel([])

            result = parse_template_excel(excel_bytes)

            assert result.valid is False
            assert any("Nenhum dado" in e for e in result.errors)

        def test_skips_empty_rows(self):
            """Test that completely empty rows are skipped."""
            rows = [
                ["General", "Check 1", "Text", ""],
                ["", "", "", ""],  # Empty row - should be skipped
                ["General", "Check 2", "Text", ""],
            ]
            excel_bytes = create_test_excel(rows)

            result = parse_template_excel(excel_bytes)

            assert result.valid is True
            assert result.summary["field_count"] == 2

        def test_invalid_file_format(self):
            """Test error for non-Excel file."""
            result = parse_template_excel(b"not an excel file")

            assert result.valid is False
            assert any("invalido" in e or "corrompido" in e for e in result.errors)
    ```

    Run tests to verify parser works correctly.
  </action>
  <verify>
    Run: cd C:\Users\xande\smarthand-reports\backend && python -m pytest tests/test_excel_parser.py -v
  </verify>
  <done>
    - All 11 test cases pass
    - Parser correctly validates all required fields
    - Parser collects ALL errors (not fail-fast)
    - Parser handles edge cases (empty rows, comma/slash options, invalid files)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. openpyxl is in requirements.txt and installed
2. parse_template_excel function is importable from app.services.excel_parser
3. All unit tests pass (pytest tests/test_excel_parser.py)
4. Parser returns ParseResult with valid=True and sections for valid files
5. Parser returns ParseResult with valid=False and ALL errors for invalid files
</verification>

<success_criteria>
- Excel parser validates Section, Script Step, Result Type columns
- Dropdown fields require at least 2 options
- All errors collected and returned (not fail-fast)
- Parser handles both slash and comma separators for options
- Empty rows are skipped, empty files return error
- Invalid/corrupted files return descriptive error
</success_criteria>

<output>
After completion, create `.planning/phases/04-template-management/04-02-SUMMARY.md`
</output>
